### **1. Таблица метасимволов (Globbing/подстановки в оболочке)**
Эти шаблоны используются оболочкой (bash, zsh) для сопоставления с именами файлов.

| Шаблон | Соответствие | Примеры использования |
|---|---|---|
| `*` | Любая строка длиной **0 или более** любых символов. | `ls *.txt` — все файлы с расширением `.txt`. `rm data_*` — все файлы, начинающиеся с `data_`. |
| `?` | **Любой один** символ. | `ls photo?.jpg` — `photo1.jpg`, `photoA.jpg`, но не `photo10.jpg`. |
| `???` | **Любые три символа**. Количество `?` задает длину. | `ls ???.log` — файлы типа `abc.log`, `123.log` (ровно 3 символа до точки). |
| `[abc]` | **Любой один** символ из указанного набора в скобках. | `ls file[123].txt` — `file1.txt`, `file2.txt`, `file3.txt`. |
| `[a-z]` | Любой один символ из диапазона. | `ls chapter_[a-c].md` — `chapter_a.md`, `chapter_b.md`, `chapter_c.md`. |
| `[!abc]` или `[^abc]`| Любой один символ, **НЕ** входящий в указанный набор. | `ls report[!0-9].txt` — `reportA.txt`, `report_.txt`, но не `report1.txt`. |
| `[[:alpha:]]` | Любой **буквенный** символ (внутри своих `[ ]`!). | `ls letter_[[:alpha:]].txt` — `letter_a.txt`, `letter_Z.txt`. |
| `[[:digit:]]` | Любая **цифра** от 0 до 9. | `mv data_[[:digit:]] backup/` — переместит `data_1`, `data_5` и т.д. |
| `[[:alnum:]]` | Любой **буквенно-цифровой** символ. | `touch test_[[:alnum:]][[:alnum:]]` — создаст файлы с именами из двух букв/цифр. |
| `[[:lower:]]` | Любой символ в **нижнем регистре**. | `ls *[[:lower:]].conf` — файлы, чье имя перед `.conf` заканчивается на строчную букву. |
| `[[:upper:]]` | Любой символ в **верхнем регистре**. | `ls LOG_[[:upper:]]` — `LOG_A`, `LOG_X`. |
| `[[:space:]]` | Любой **пробельный** символ (пробел, табуляция и др.). Используется редко в именах файлов, но полезно в скриптах. | |
| `[[:punct:]]` | Любой **знак пунктуации**. | |

---

### **2. Создание и управление файлами**

#### **2.1. Базовое создание**
*   **Пустой файл:** `touch file1.txt`
*   **Просмотр:** `cat file1.txt`
*   **Создать и открыть в редакторе:** `vim file2.txt`

#### **2.2. Массовое создание через фигурные скобки `{}`**
*   **Группа файлов:**
    ```bash
    touch file{1..3}.txt      # Создаст file1.txt, file2.txt, file3.txt
    rm -rf file{1..3}.txt     # Удалит их
    ```
*   **Группа директорий:**
    ```bash
    mkdir /projects/{bin,logs,src,backup}  # Создаст 4 каталога внутри /projects
    ```
*   **Комбинированные шаблоны:**
    ```bash
    touch {alpha,beta}_{01..03}.log
    # Создаст: alpha_01.log, alpha_02.log, alpha_03.log,
    #          beta_01.log,  beta_02.log,  beta_03.log
    ```

---

### **3. Создание файлов заданного размера (dd)**

#### **3.1. Файл, заполненный нулями (быстро, для тестов)**
```bash
# Создать файл размером 1000 МБ (1 ГБ) из нулей.
dd if=/dev/zero of=./big_file.img bs=10M count=100
```
*   `if=/dev/zero` — источник данных (поток нулевых байтов).
*   `of=./big_file.img` — выходной файл.
*   `bs=10M` — размер блока для чтения/записи (10 Мегабайт).
*   `count=100` — количество блоков. Итоговый размер: `10M * 100 = 1000M`.

#### **3.2. Файл со случайным содержимым (для криптографии/тестов)**
```bash
# Создать файл размером 500 МБ со случайными данными.
dd if=/dev/urandom of=./secret_data.bin bs=1M count=500
```
*   `if=/dev/urandom` — источник псевдослучайных данных.

#### **3.3. Сложный пример: создание загрузочного USB-образа**
```bash
# Копирование ISO-образа на USB-накопитель (/dev/sdX)
dd if=./ubuntu-22.04.iso of=/dev/sdb bs=4M status=progress oflag=sync
```
*   `status=progress` — показывает прогресс операции.
*   `oflag=sync` — использует синхронные операции записи для надежности.

---

### **4. Символические и жесткие ссылки (ln)**

#### **4.1. Создание ссылок**
*   **Символическая ссылка (как ярлык):**
    ```bash
    ln -s /путь/к/оригинальному/файлу ./моя_ссылка
    ln -sf /новый/файл ./моя_ссылка  # Принудительное обновление цели ссылки
    ```
*   **Жесткая ссылка (альтернативное имя для тех же данных на диске):**
    ```bash
    ln /путь/к/файлу ./жесткая_ссылка
    # Оба имени (файл и жесткая_ссылка) теперь указывают на один inode и данные.
    ```

#### **4.2. Поиск и управление ссылками**
*   **Найти ВСЕ жесткие ссылки на конкретный файл (в пределах одной ФС):**
    ```bash
    find /home/username -xdev -samefile /путь/к/оригиналу
    ```
    *   `-xdev` — не переходить на другие файловые системы.
    *   `-samefile` — ищет файлы с тем же inode.

*   **Найти все файлы по номеру inode:**
    ```bash
    find /var/log -inum 123456
    ```

*   **Найти и безопасно удалить ВСЕ жесткие ссылки на файл:**
    ```bash
    find . -xdev -samefile file1 -print0 | xargs -0 rm -v
    ```
    *   `-print0` и `xargs -0` корректно обрабатывают имена с пробелами.

*   **Удалить все символические ссылки в каталоге, указывающие на несуществующий файл (битые ссылки):**
    ```bash
    find . -type l -xtype l -delete
    ```
    *   `-type l` — ищем символические ссылки.
    *   `-xtype l` — чья цель также является символической ссылкой (или не существует).

---

### **5. Копирование (cp)**

#### **5.1. Базовые операции**
*   **Копирование каталога рекурсивно:**
    ```bash
    cp -rv ~/source_project/ ~/backups/    # -v для подробного вывода
    ```
*   **Копирование нескольких файлов в одну директорию:**
    ```bash
    cp file1.conf file2.conf /etc/         # Классический способ
    cp -t /destination/ file1.txt file2.txt # Способ с опцией -t
    ```

#### **5.2. Создание резервных копий с датой**
```bash
# Простой бэкап
cp config.yml{,.bak}  # Создаст config.yml.bak

# Бэкап с меткой времени
cp important_document.pdf important_document_$(date +%F_%H-%M).pdf
# Результат: important_document_2023-12-19_14-30.pdf

# Архивация лог-файла в конце дня
cp /var/log/app.log /backup/app_$(date +%Y%m%d).log
```

#### **5.3. Интерактивное и безопасное копирование**
```bash
cp -i *.txt ~/documents/     # Спрашивать подтверждение перед перезаписью
cp -n *.log ~/archive/       # Не перезаписывать существующие файлы (no clobber)
cp -a /home/user /backup/    # Скопировать рекурсивно, сохраняя все атрибуты (архивный режим)
```

---

### **6. Команда tee (разветвление вывода)**

#### **6.1. Основное назначение**
Перенаправляет `STDIN` одновременно в `STDOUT` (на экран) и в один или несколько файлов.
```bash
echo "Новая строка конфига" | sudo tee -a /etc/config.cfg
# Без tee пришлось бы: sudo sh -c 'echo "..." >> /etc/config.cfg'
```

#### **6.2. Сложные примеры**
*   **Логирование с временной меткой:**
    ```bash
    ls -la | tee >(awk '{print strftime("%F %T"), $0}' >> full.log) > simple.log
    # Вывод команды ls будет в simple.log,
    # а в full.log — каждая строка с датой и временем в начале.
    ```

*   **Отладка конвейера:**
    ```bash
    cat data.csv | tee raw_output.log | grep "ERROR" | tee errors_only.log | wc -l
    # 1. Сохраняет исходные данные в raw_output.log.
    # 2. Фильтрует ошибки, сохраняет их в errors_only.log.
    # 3. Считает количество строк с ошибками.
    ```

*   **Создание конфига с подтверждением:**
    ```bash
    cat <<EOF | tee /tmp/new_config.conf
    Host example
        HostName 192.168.1.1
        User admin
    EOF
    # Вы увидите содержимое на экране, и оно же запишется в файл.
    ```

---
**Примечание:** Помните, что метасимволы из раздела 1 (`*`, `?`, `[...]`) — это **glob-паттерны оболочки**. Они отличаются от **регулярных выражений**, используемых в `grep`, `sed`, `awk`. Не путайте их контекст использования.
