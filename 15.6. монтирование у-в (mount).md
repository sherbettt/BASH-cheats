### Использование утилиты `mount` в Linux
Утилита `mount` используется для подключения файловых систем (разделов дисков, сетевых ресурсов и т.д.) к каталогу в файловой системе Linux.

#### Основные команды:
1. **Просмотр всех смонтированных файловых систем**  
   ```bash
   mount
   ```
   - **Фильтрация вывода** (например, только ext4):  
     ```bash
     mount -t ext4
     ```
     ```bash
     # фильтрация по типу файловой системы
     mount | grep -E '^/dev'
     ```

2. **Монтирование устройства**  
   ```bash
   mount /dev/sdX# /путь/к/точке_монтирования
   ```
   - Пример:  
     ```bash
     mount /dev/sdb1 /mnt/mydrive
     ```

3. **Монтирование с указанием типа файловой системы**  
   ```bash
   mount -t тип_фс /dev/sdX# /точка_монтирования
   ```
   - Пример (для NTFS):  
     ```bash
     mount -t ntfs /dev/sdc1 /mnt/win
     ```

4. **Монтирование с опциями**  
   ```bash
   mount -o опции /dev/sdX# /точка_монтирования
   ```
   - Примеры опций:  
     ```bash
     mount -o ro /dev/sdb1 /mnt/readonly  # только для чтения
     mount -o remount,rw /                 # перемонтировать корень в режиме записи
     ```

5. **Монтирование всех файловых систем из `/etc/fstab`**  
   ```bash
   mount -a
   ```

6. **Размонтирование**  
   ```bash
   umount /точка_монтирования  # или
   umount /dev/sdX#
   ```

---

### Использование утилиты `findmnt` в Linux
Утилита `findmnt` отображает информацию о смонтированных файловых системах в удобном формате (в виде дерева или списка).

#### Основные команды:
1. **Вывод всех смонтированных ФС в виде дерева**  
   ```bash
   findmnt
   ```

2. **Вывод в виде списка**  
   ```bash
   findmnt -l
   ```

3. **Поиск по точке монтирования**  
   ```bash
   findmnt /точка_монтирования
   ```
   - Пример:  
     ```bash
     findmnt /mnt/mydrive
     ```

4. **Поиск по устройству**  
   ```bash
   findmnt /dev/sdX#
   ```
   - Пример:  
     ```bash
     findmnt /dev/sdb1
     ```

5. **Фильтрация по типу файловой системы**  
   ```bash
   findmnt -t тип_фс
   ```
   - Пример (показать все NFS):  
     ```bash
     findmnt -t nfs
     ```

6. **Вывод информации в JSON**  
   ```bash
   findmnt --json
   ```

7. **Поиск в `/etc/fstab`** (не смонтированные ресурсы)  
   ```bash
   findmnt --fstab
   ```

---

### Примеры совместного использования:
1. **Монтирование и проверка**  
   ```bash
   mount /dev/sdb1 /mnt/data && findmnt /mnt/data
   ```

2. **Поиск всех смонтированных ext4-разделов**  
   ```bash
   findmnt -t ext4
   ```

3. **Проверка занятости точки монтирования перед размонтированием**  
   ```bash
   findmnt /mnt/data  # Проверяем, смонтировано ли устройство
   umount /mnt/data   # Размонтируем, если нет активности
   ```
----------------------------------

Конкретный пример с Jira кластером из статьи [Настройка Jira Data Center cluster](https://github.com/sherbettt/BASH-cheats/blob/main/System%20engineering/18.%20Настройка%20Jira%20Data%20Center%20cluster.md)

### Полная последовательность настройки высокодоступного NFS-кластера с плавающим IP

#### 1. Подготовка всех узлов (prox4, pmx5, pmx6)

**На всех серверах выполнить:**

```bash
# Остановка всех NFS-монтирований
umount /mnt/share 2>/dev/null
umount /mnt/pve/nfs_storage 2>/dev/null
umount /mnt/pve/nfs-storage 2>/dev/null

# Установка необходимых пакетов
apt update && apt install -y nfs-kernel-server keepalived

# Проверка статуса NFS
systemctl status nfs-kernel-server
```

#### 2. Настройка экспорта NFS (актуальная конфигурация)

**На всех узлах оставляем существующий /etc/exports без изменений:**

```bash
# /etc/exports содержимое (уже правильно настроено):
/stg/8tb/share  192.168.87.17(rw,sync,no_subtree_check) 192.168.87.20(rw,sync,no_subtree_check) 192.168.87.6(rw,sync,no_subtree_check)

# Применяем изменения
exportfs -ra
systemctl restart nfs-kernel-server
```

#### 3. Настройка Keepalived для плавающего IP (192.168.87.3)

**На prox4 (основной узел, 192.168.87.17):**

```bash
cat > /etc/keepalived/keepalived.conf <<'EOF'
! Configuration File for keepalived
global_defs {
    router_id LVS_DEVEL
}

vrrp_instance VI_NFS {
    state MASTER
    interface eth0
    virtual_router_id 51
    priority 150
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass nfs_ha_pass
    }
    virtual_ipaddress {
        192.168.87.3/24
    }
    notify_master "/usr/local/bin/nfs_vip_up.sh"
    notify_backup "/usr/local/bin/nfs_vip_down.sh"
    notify_fault "/usr/local/bin/nfs_vip_down.sh"
}
EOF
```

**На pmx5 (резервный узел, 192.168.87.20):**

```bash
cat > /etc/keepalived/keepalived.conf <<'EOF'
! Configuration File for keepalived
global_defs {
    router_id LVS_DEVEL
}

vrrp_instance VI_NFS {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 100
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass nfs_ha_pass
    }
    virtual_ipaddress {
        192.168.87.3/24
    }
    notify_master "/usr/local/bin/nfs_vip_up.sh"
    notify_backup "/usr/local/bin/nfs_vip_down.sh"
    notify_fault "/usr/local/bin/nfs_vip_down.sh"
}
EOF
```

**На pmx6 (резервный узел, 192.168.87.6):**

```bash
cat > /etc/keepalived/keepalived.conf <<'EOF'
! Configuration File for keepalived
global_defs {
    router_id LVS_DEVEL
}

vrrp_instance VI_NFS {
    state BACKUP
    interface eth0
    virtual_router_id 51
    priority 50
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass nfs_ha_pass
    }
    virtual_ipaddress {
        192.168.87.3/24
    }
    notify_master "/usr/local/bin/nfs_vip_up.sh"
    notify_backup "/usr/local/bin/nfs_vip_down.sh"
    notify_fault "/usr/local/bin/nfs_vip_down.sh"
}
EOF
```

#### 4. Создание скриптов уведомлений для Keepalived

**На всех узлах создаем:**

```bash
cat > /usr/local/bin/nfs_vip_up.sh <<'EOF'
#!/bin/bash
# Скрипт выполняется при переходе в MASTER состояние
logger "NFS VIP 192.168.87.3 перешел на $(hostname)"
systemctl restart nfs-kernel-server
EOF

cat > /usr/local/bin/nfs_vip_down.sh <<'EOF'
#!/bin/bash
# Скрипт выполняется при переходе в BACKUP/FAULT состояние
logger "NFS VIP 192.168.87.3 покидает $(hostname)"
EOF

chmod +x /usr/local/bin/nfs_vip_*.sh
```

#### 5. Настройка монтирования NFS через плавающий IP

**На всех узлах правим /etc/fstab:**

```bash
# Создаем резервную копию
cp /etc/fstab /etc/fstab.bak

# Обновляем fstab (заменяем существующие записи)
sed -i '/192.168.87/d' /etc/fstab
cat >> /etc/fstab <<'EOF'
# Единая точка монтирования для Proxmox
192.168.87.3:/stg/8tb/share /mnt/pve/nfs_storage nfs rw,hard,intr,noatime,vers=4.2,_netdev,timeo=300,retrans=3,proto=tcp 0 0

# Дополнительная точка монтирования
192.168.87.3:/stg/8tb/share /mnt/share nfs rw,hard,intr,noatime,vers=4.2,_netdev,timeo=300,retrans=3,proto=tcp 0 0
EOF

# Применяем изменения
systemctl daemon-reload
mount -a
```

#### 6. Запуск и проверка сервисов

**На всех узлах выполняем:**

```bash
# Включаем и запускаем keepalived
systemctl enable --now keepalived

# Проверяем статус
systemctl status keepalived
ip addr show eth0 | grep 192.168.87.3

# Перезапускаем NFS
systemctl restart nfs-kernel-server
```

#### 7. Проверка отказоустойчивости

1. На текущем master-узле (где висит 192.168.87.3):
```bash
# Проверяем текущий master
ip a show eth0 | grep 192.168.87.3

# Имитируем сбой
systemctl stop keepalived
```

2. На резервных узлах проверяем переход VIP:
```bash
watch -n 1 'ip a show eth0 | grep 192.168.87.3'
```

3. Проверяем доступность NFS:
```bash
ls /mnt/share
touch /mnt/share/failover_test && rm /mnt/share/failover_test
```

#### 8. Финализация настройки

**На всех узлах:**

```bash
# Устанавливаем мониторинг
apt install -y monit

# Настраиваем monit для проверки NFS
cat > /etc/monit/conf.d/nfs_check <<'EOF'
check filesystem nfs_mount with path /mnt/share
    if space usage > 90% then alert
    if inode usage > 90% then alert
    if changed fsflags then alert
EOF

systemctl enable --now monit
```

#### 9. Дополнительные рекомендации

1. Для лучшей производительности NFS можно добавить в /etc/sysctl.conf:
```bash
echo "sunrpc.tcp_max_slot_table_entries=128" >> /etc/sysctl.conf
sysctl -p
```

2. Настройка firewall (если используется):
```bash
ufw allow from 192.168.87.0/24 to any port nfs
ufw allow proto vrrp
```

3. Логирование для отладки:
```bash
echo "local0.* /var/log/keepalived.log" >> /etc/rsyslog.conf
systemctl restart rsyslog
```


