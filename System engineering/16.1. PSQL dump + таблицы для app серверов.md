# Проверка Лидера Patroni 

## Смотрим лидера/реплику и конфигурацию
```bash
root@app ~ > patronictl -c /etc/patroni/config.yml show-config

root@app /var/backups/postgresql > patronictl -c /etc/patroni/config.yml topology
+ Cluster: postgres ----------+---------+---------+-----+-----------+
| Member | Host               | Role    | State   |  TL | Lag in MB |
+--------+--------------------+---------+---------+-----+-----------+
| app3   | 192.168.87.62:5433 | Leader  | running | 400 |           |
| + app  | 192.168.87.60:5433 | Replica | running | 400 |         0 |
| + app2 | 192.168.87.61:5433 | Replica | running | 400 |         0 |
+--------+--------------------+---------+---------+-----+-----------+
```

## Переключаем мастер на app сервер
```bash
# Выполняем switchover (переключение ролей)
patronictl -c /etc/patroni/config.yml switchover --candidate app --force

# Или используем более явную команду (выбираем из app, app2, app3)
patronictl -c /etc/patroni/config.yml switchover --master app --candidate app

# Проверяем результат
patronictl -c /etc/patroni/config.yml topology

# Дополнительная проверка на самой ноде app
sudo -u postgres psql -h /var/lib/postgresql/patroni -p 5433 -c "SELECT pg_is_in_recovery();"
# Если вернет 'f' - это мастер, если 't' - реплика

##--------
# Если switchover не работает
patronictl -c /etc/patroni/config.yml failover --candidate app

# Или перезапустить мастер и заставить выбрать новый
patronictl -c /etc/patroni/config.yml restart --role master
```
<br/>


# Проверка подключения БД 

## Проверка портов
```bash
root@app /var/backups/postgresql > ss -tulpn | grep -E "(5433|5432|haproxy|patroni)"
tcp   LISTEN 0      4096   192.168.87.60:7000       0.0.0.0:*    users:(("haproxy",pid=277,fd=6))                                                                                               
tcp   LISTEN 0      5      192.168.87.60:8008       0.0.0.0:*    users:(("patroni",pid=272235,fd=5))                                                                                            
tcp   LISTEN 0      4096       127.0.0.1:5434       0.0.0.0:*    users:(("haproxy",pid=277,fd=9))                                                                                               
tcp   LISTEN 0      4096       127.0.0.1:5435       0.0.0.0:*    users:(("haproxy",pid=277,fd=10))                                                                                              
tcp   LISTEN 0      4096       127.0.0.1:5433       0.0.0.0:*    users:(("haproxy",pid=277,fd=8))                                                                                               
tcp   LISTEN 0      4096   192.168.87.60:5432       0.0.0.0:*    users:(("haproxy",pid=277,fd=7))                                                                                               
tcp   LISTEN 0      4096   192.168.87.60:5433       0.0.0.0:*    users:(("postgres",pid=272546,fd=5))  
```

## Проверка подключения через порт
```bash
root@app ~ > sudo -u postgres psql -p 5432 -h 192.168.87.60
psql (15.14 (Debian 15.14-0+deb12u1))
Введите "help", чтобы получить справку.

# аналогично и sudo -u postgres psql -p 5433 -h 192.168.87.60
```

## Проверка подключения через сокет
```bash
root@app ~ > su - postgres 
postgres@app:~$ psql 
psql: ошибка: подключиться к серверу через сокет "/var/run/postgresql/.s.PGSQL.5432" не удалось: Нет такого файла или каталога
        Сервер действительно работает локально и принимает подключения через этот сокет?
```
Значит нужно подключаться через сокет
```bash
root@app ~ > find / -name ".s.PGSQL.5433" 2>/dev/null
/var/lib/postgresql/patroni/.s.PGSQL.5433
root@app ~ > psql -h /var/lib/postgresql/patroni -p 5433 -U postgres
psql (15.14 (Debian 15.14-0+deb12u1))
Введите "help", чтобы получить справку.

postgres=# 
```

## Найдём файл .pgpass, если он существует
```bash
root@app ~ > find / -name ".pgpass" 2>/dev/null 
/var/lib/postgresql/.pgpass
```
 Пароли БД можно посмотреть ещё в `/etc/patroni/config.yml`


## Создать директории для дампов
```bash
root@app3 ~ > mkdir -p /var/backups/postgresql/
root@app3 ~ > chown postgres:postgres /var/backups/postgresql/
```
<br/>


--------------------------------------------------------------------------------------------
# Создание дампов БД

## Проверка БД и ролей и отношений
```bash
# роли
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "\du+"

# БД
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "\l"
psql -h 192.168.87.60 -p 5433 -U postgres -c "\l"

# отношения
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "\dt+" | ccat
```

## **1. На МАСТЕРЕ (app):**

### Создаем полный бэкап всех БД:

**`pg_dumpall`** - это обертка, которая:
- Делает pg_dumpall -g для глобальных объектов
- Для каждой БД запускает pg_dump отдельно
- Объединяет всё в один SQL файл

```bash
# Переходим в директорию бэкапов
cd /var/backups/postgresql/

# Создаем папку для бэкапа с мастера
mkdir -p master_full_$(date +%Y%m%d_%H%M)
cd master_full_$(date +%Y%m%d_%H%M)

# 1. Бэкап ВСЕХ БД одним файлом (просто на всякий случай)
pg_dumpall -h /var/lib/postgresql/patroni -p 5433 -U postgres -f all_databases.sql

# 2. Дамп всех БД со сжатием
pg_dumpall -h /var/lib/postgresql/patroni -p 5433 -U postgres | gzip -9 > all_databases.sql.gz

        # Чтобы разархивировать файл all_databases.sql.gz
         gzip -d all_databases.sql.gz
        # или
         gunzip all_databases.sql.gz
        # проверка целостности архива
         gzip -t all_databases.sql.gz
        # посмотреть первые 20 строк
         zcat all_databases.sql.gz | head -20
        # для распаковки с указанием другого имени файла
         gzip -c -d all_databases.sql.gz > restored_databases.sql

# 3. Бэкап глобальных объектов (роли) - ТОЛЬКО НА МАСТЕРЕ!
pg_dumpall -h /var/lib/postgresql/patroni -p 5433 -U postgres -g -f globals.sql

        # Для восстановления глобальных объектов (ролей, табличных пространств)
         psql -f globals.sql

# 3. Бэкап каждой БД отдельно в сжатом формате
for DB in logging_db media_db pbx_master2 pbxv2 pbxv2_stat rt_pbx_v2_71 rt_pbx_v2_logging_71 rt_pbx_v2_media_71 rt_pbx_v2_stat_71 test_db; do
    echo "Бэкап БД: $DB"
    pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres -Fc -Z 9 -f ${DB}.dump ${DB}
done

# 4. Проверяем что создалось
ls -lh *.dump

# 5. Смена прав
chown -R postgres:postgres /var/backups/postgresql/

# 6. Создание от имени postgres сразу
sudo -u postgres pg_dumpall -h /var/lib/postgresql/patroni -p 5433 -g -f globals.sql
sudo -u postgres pg_dumpall -h /var/lib/postgresql/patroni -p 5433 -f all_databases.sql
```

## **2. На РЕПЛИКАХ (app2 и app3):**

### На КАЖДОЙ реплике выполняем:

```bash
# Переходим в директорию бэкапов
cd /var/backups/postgresql/

# Создаем папку для бэкапа с реплики
mkdir -p replica_$(hostname)_$(date +%Y%m%d_%H%M)
cd replica_$(hostname)_$(date +%Y%m%d_%H%M)

# Дамп всех БД со сжатием
pg_dumpall -h /var/lib/postgresql/patroni -p 5433 -U postgres | gzip -9 > all_databases.sql.gz

# Бэкап каждой БД отдельно (глобальные объекты НЕ трогаем)
for DB in logging_db media_db pbx_master2 pbxv2 pbxv2_stat rt_pbx_v2_71 rt_pbx_v2_logging_71 rt_pbx_v2_media_71 rt_pbx_v2_stat_71 test_db; do
    echo "Бэкап БД: $DB"
    pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres -Fc -Z 9 -f ${DB}.dump ${DB}
done

# Проверяем
ls -lh *.dump
```

## **2.1. На всех серверах делаем одинаково (использовать формат directory или custom)**
```bash
cd /var/backups/postgresql/
mkdir -p smart_backup_$(date +%Y%m%d_%H%M)
cd smart_backup_$(date +%Y%m%d_%H%M)

# Для каждой БД создаем сжатый дамп
for DB in $(sudo -u postgres psql -h /var/lib/postgresql/patroni -p 5433 -t -c "SELECT datname FROM pg_database WHERE datistemplate = false AND datname NOT IN ('postgres');"); do
    echo "Бэкап $DB"
    sudo -u postgres pg_dump -h /var/lib/postgresql/patroni -p 5433 -Fc -Z 9 -f ${DB}.dump ${DB}
done

# Только на мастере добавляем globals
if sudo -u postgres psql -h /var/lib/postgresql/patroni -p 5433 -t -c "SELECT pg_is_in_recovery();" | grep -q "f"; then
    echo "Это мастер, добавляем глобальные объекты"
    sudo -u postgres pg_dumpall -h /var/lib/postgresql/patroni -p 5433 -g -f globals.sql
fi
##--------

# Посмотреть размеры
du -sh /var/backups/postgresql/*/

# Ваш текущий (текстовый): 4.6ГБ
# Custom формат (сжатый): ~1-2ГБ (в 2-4 раза меньше)
# Directory формат: еще меньше, + параллельный бэкап
```


## **3. Проверить размеры таблиц в самых больших БД:**

```bash
# Вариант 1: Используем pg_stat_user_tables (нужно знать правильные имена колонок)
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d pbxv2 -c "
SELECT 
    schemaname,
    relname as tablename,
    pg_size_pretty(pg_total_relation_size(schemaname || '.' || relname)) as total_size,
    n_live_tup as rows
FROM pg_stat_user_tables
ORDER BY pg_total_relation_size(schemaname || '.' || relname) DESC
LIMIT 10;
"

# Вариант 2: Используем pg_class и pg_namespace (более надежно)
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d pbxv2 -c "
SELECT 
    nspname as schemaname,
    relname as tablename,
    pg_size_pretty(pg_total_relation_size(c.oid)) as total_size,
    CASE 
        WHEN c.reltuples < 0 THEN 0
        ELSE c.reltuples::bigint 
    END as estimated_rows,
    pg_size_pretty(pg_relation_size(c.oid)) as table_size,
    pg_size_pretty(pg_total_relation_size(c.oid) - pg_relation_size(c.oid)) as index_size
FROM pg_class c
LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind = 'r'
  AND nspname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(c.oid) DESC
LIMIT 15;
"

# Вариант 3: Простой и понятный
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d pbxv2 -c "\dt+"

# Вариант 4: Только 10 самых больших таблиц с деталями
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d pbxv2 -c "
SELECT 
    nspname as \"Схема\",
    relname as \"Таблица\",
    pg_size_pretty(pg_total_relation_size(c.oid)) as \"Общий размер\",
    pg_size_pretty(pg_relation_size(c.oid)) as \"Размер данных\",
    pg_size_pretty(pg_total_relation_size(c.oid) - pg_relation_size(c.oid)) as \"Размер индексов\",
    pg_stat_get_live_tuples(c.oid) as \"Кол-во строк\"
FROM pg_class c
LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind IN ('r', 'p')  -- обычные и партиционированные таблицы
  AND nspname NOT IN ('pg_catalog', 'information_schema')
  AND nspname !~ '^pg_toast'
ORDER BY pg_total_relation_size(c.oid) DESC
LIMIT 10;
"

# Для rt_pbx_v2_71
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d rt_pbx_v2_71 -c "\dt+"

# Для logging_db
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d logging_db -c "\dt+"

# Для media_db
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d media_db -c "\dt+"
```

## **4. Проверить целостность бэкапов, если не сжимали:**
```bash
# На любой ноде проверяем один из дампов
pg_restore -l /var/backups/postgresql/master_full_*/pbxv2.dump | head -5

# Или проверить все дампы
for DUMP in /var/backups/postgresql/master_full_*/*.dump; do
    echo "Проверка: $(basename $DUMP)"
    pg_restore -l "$DUMP" > /dev/null && echo "  OK" || echo "  ПОВРЕЖДЕН!"
done
```

## **4.1. Проверить целостность бэкапов
```bash
# Посмотреть начало файла
head -50 all_databases.sql

# Посмотреть конец файла
tail -20 all_databases.sql

# Посмотреть какие БД внутри
grep "^\\\connect\|^CREATE DATABASE" all_databases.sql | head -20

# Узнать размер каждой БД в бэкапе
grep "Database:" all_databases.sql
```


## **5. Посмотреть какие таблицы входят в бэкап:**
```bash
# Посмотреть таблицы в дампе pbxv2
pg_restore -l /var/backups/postgresql/master_full_*/pbxv2.dump | grep "TABLE"

# Посмотреть ВСЕ объекты в дампе
pg_restore -l /var/backups/postgresql/master_full_*/pbxv2.dump
```

## **6. Быстрая проверка размера всех БД:**

```bash
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "
SELECT 
    datname as \"База данных\",
    pg_size_pretty(pg_database_size(datname)) as \"Размер\",
    (pg_database_size(datname) / 1024 / 1024) as \"Размер в MB\"
FROM pg_database 
WHERE datistemplate = false
ORDER BY pg_database_size(datname) DESC;
"
```

## **7. Создать бэкап ОДНОЙ конкретной БД с разными форматами:**

```bash
# Для важной БД pbxv2 делаем несколько форматов
cd /var/backups/postgresql/

# 1. Plain SQL (можно читать)
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres -Fp -f pbxv2_plain.sql pbxv2

# 2. Custom сжатый (для восстановления)
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres -Fc -Z 9 -f pbxv2_custom.dump pbxv2

# 3. Directory формат (параллельный бэкап)
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres -Fd -Z 9 -f pbxv2_dir/ pbxv2
```

## **8. Проверить разницу в размерах форматов:**

```bash
ls -alh /var/backups/postgresql/pbxv2_*
du -sh /var/backups/postgresql/pbxv2_dir/
```

## **9. Восстановить ТОЛЬКО одну таблицу из бэкапа (пример):**

```bash
# Если нужно восстановить только таблицу 'users' из БД pbxv2
# Сначала смотрим что есть в дампе
pg_restore -l /var/backups/postgresql/master_full_*/pbxv2.dump | grep "TABLE.*users"

# Создаем файл со списком что восстанавливать
echo "TABLE public.users" > restore_list.txt

# Восстанавливаем только эту таблицу
pg_restore -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -d postgres \
    -L restore_list.txt \
    /var/backups/postgresql/master_full_*/pbxv2.dump
```

## **10. Итоговая проверка что на всех серверах есть бэкапы:**

```bash
# На app (мастер):
ls -la /var/backups/postgresql/master_full_*/

# На app2 (реплика):
ssh root@app2 "ls -la /var/backups/postgresql/replica_app2_*/"

# На app3 (реплика):
ssh root@app3 "ls -la /var/backups/postgresql/replica_app3_*/"

# Проверить размеры
ssh root@app2 "du -sh /var/backups/postgresql/*/"
ssh root@app3 "du -sh /var/backups/postgresql/*/"
```

## **Важные моменты:**

1. **На мастере (app) есть:**
   - `globals.sql` - роли и привилегии
   - `all_databases.sql` - все БД одним файлом
   - `*.dump` - каждая БД отдельно

2. **На репликах (app2, app3) есть:**
   - Только `*.dump` файлы с данными БД
   - Нет глобальных объектов (их можно взять только с мастера)

3. **Все дампы .dump идентичны** на всех трех серверах (кроме globals.sql)
<br/>

--------------------------------------------------------------------------------------------
# Создание дампа (Только СХЕМА (структура) - БЕЗ данных)

## **1. Только СХЕМА (структура) - БЕЗ данных**

### A. ОДНОЙ БД:
```bash
# 1. Только схема (без данных)
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -s -Fc -f /var/backups/postgresql/pbxv2_schema_only.dump \
    pbxv2

# 2. Только схема в читаемом SQL формате
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -s -f /var/backups/postgresql/pbxv2_schema_only.sql \
    pbxv2
```

### B. ВСЕХ БД (только схемы):
```bash
# Для каждой БД создаем дамп только схемы
for DB in logging_db media_db pbx_master2 pbxv2 pbxv2_stat rt_pbx_v2_71 rt_pbx_v2_logging_71 rt_pbx_v2_media_71 rt_pbx_v2_stat_71 test_db; do
    echo "Схема БД: $DB"
    pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
        -s -Fc -f /var/backups/postgresql/${DB}_schema.dump \
        ${DB}
done
```

## **2. Только ДАННЫЕ - БЕЗ схемы**

### A. ОДНОЙ БД:
```bash
# 1. Только данные (INSERT) - в SQL формате
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -a -f /var/backups/postgresql/pbxv2_data_only.sql \
    pbxv2

# 2. Только данные в custom формате
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -a -Fc -f /var/backups/postgresql/pbxv2_data_only.dump \
    pbxv2
```

### B. Только данные определенных таблиц:
```bash
# Только данные из таблиц users и calls
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -a -t users -t calls -f /var/backups/postgresql/users_calls_data.sql \
    pbxv2
```

## **3. Только ОПРЕДЕЛЕННЫЕ ТАБЛИЦЫ**

### A. Структура и данные:
```bash
# Конкретные таблицы
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -t users -t calls -Fc -f /var/backups/postgresql/users_calls_full.dump \
    pbxv2
```

### B. Только определенные схемы:
```bash
# Все таблицы из схемы public
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -n public -Fc -f /var/backups/postgresql/public_schema.dump \
    pbxv2
```

## **4. Только ИНДЕКСЫ, КОНСТРЕЙНТЫ, ТРИГГЕРЫ**

### A. Только индексы:
```bash
# Сначала получаем список индексов
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d pbxv2 -c "
SELECT indexdef 
FROM pg_indexes 
WHERE schemaname = 'public' 
ORDER BY tablename, indexname;
" > /var/backups/postgresql/pbxv2_indexes.sql
```

### B. Только внешние ключи:
```bash
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d pbxv2 -c "
SELECT 
    conname as constraint_name,
    conrelid::regclass as table_name,
    pg_get_constraintdef(oid) as constraint_definition
FROM pg_constraint 
WHERE contype = 'f'
ORDER BY conrelid::regclass::text, conname;
" > /var/backups/postgresql/pbxv2_foreign_keys.sql
```

## **5. РАЗДЕЛЬНЫЙ бэкап: схема отдельно, данные отдельно**

```bash
# Создаем директорию
mkdir -p /var/backups/postgresql/separate_backup_$(date +%Y%m%d_%H%M)
cd /var/backups/postgresql/separate_backup_$(date +%Y%m%d_%H%M)

# Для каждой БД создаем два файла
for DB in pbxv2 rt_pbx_v2_71; do  # только важные БД
    echo "Раздельный бэкап БД: $DB"
    
    # 1. Только схема
    pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
        -s -Fc -f ${DB}_schema.dump \
        ${DB}
    
    # 2. Только данные
    pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
        -a -Fc -f ${DB}_data.dump \
        ${DB}
    
    # 3. Только большие таблицы отдельно (если нужно)
    # pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    #     -a -t large_table1 -t large_table2 -Fc -f ${DB}_large_tables.dump \
    #     ${DB}
done
```

## **6. Проверить что внутри каждого типа бэкапа:**

```bash
# Проверить схему
pg_restore -l /var/backups/postgresql/pbxv2_schema_only.dump | head -20

# Проверить данные
pg_restore -l /var/backups/postgresql/pbxv2_data_only.dump | head -20

# Сравнить размеры
ls -lh /var/backups/postgresql/pbxv2_*
```

## **7. Восстановление из раздельных бэкапов:**

```bash
# Восстановить сначала схему
pg_restore -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -d new_database \
    /var/backups/postgresql/pbxv2_schema_only.dump

# Затем данные
pg_restore -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -d new_database \
    -a \
    /var/backups/postgresql/pbxv2_data_only.dump
```

## **8. Практические сценарии:**

### Сценарий 1: Бэкап для разработки (только структура)
```bash
# Разработчикам нужна только структура для тестовой БД
mkdir -p /var/backups/postgresql/dev_structure
for DB in pbxv2 rt_pbx_v2_71; do
    pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
        -s --no-comments \
        -f /var/backups/postgresql/dev_structure/${DB}_dev.sql \
        ${DB}
done
```

### Сценарий 2: Бэкап только транзакционных данных
```bash
# Бэкап только данных за последний месяц из таблицы calls
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -a -t calls \
    --where="created_at > NOW() - INTERVAL '30 days'" \
    -f /var/backups/postgresql/calls_last_30_days.sql \
    pbxv2
```

### Сценарий 3: Бэкап только настроек (маленькие таблицы)
```bash
# Маленькие таблицы с настройками
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres \
    -t settings -t config -t parameters \
    -Fc -f /var/backups/postgresql/config_tables.dump \
    pbxv2
```

## **9. Сравнение размеров разных типов бэкапов:**

```bash
# Давайте сравним для pbxv2
echo "=== Сравнение размеров бэкапов БД pbxv2 ==="
echo "1. Полный бэкап:"
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres -Fc pbxv2 | wc -c

echo "2. Только схема:"
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres -s -Fc pbxv2 | wc -c

echo "3. Только данные:"
pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres -a -Fc pbxv2 | wc -c

# Или проще посмотреть файлы
ls -lh /var/backups/postgresql/pbxv2_* 2>/dev/null
```

## **10. Полезные опции pg_dump:**

```bash
# Основные опции:
-s, --schema-only           # Только схема (без данных)
-a, --data-only             # Только данные (без схемы)
-t, --table=TABLE           # Только указанная таблица
-n, --schema=SCHEMA         # Только указанная схема
-T, --exclude-table=TABLE   # Исключить таблицу
--exclude-schema=SCHEMA     # Исключить схему
--no-owner                  # Не включать владельцев
--no-privileges             # Не включать привилегии
--no-tablespaces            # Не включать табличные пространства
--inserts                   # Использовать INSERT вместо COPY
--column-inserts            # Вставлять с именами колонок
--where="condition"         # Фильтр строк WHERE
```

## **11. Пример: Бэкап только структуры ВСЕХ БД одним файлом:**

```bash
# Создаем SQL файл для восстановления структуры всех БД
echo "-- Структура всех баз данных" > /var/backups/postgresql/all_schemas.sql
echo "-- Создано: $(date)" >> /var/backups/postgresql/all_schemas.sql
echo "" >> /var/backups/postgresql/all_schemas.sql

for DB in logging_db media_db pbx_master2 pbxv2 pbxv2_stat rt_pbx_v2_71 rt_pbx_v2_logging_71 rt_pbx_v2_media_71 rt_pbx_v2_stat_71 test_db; do
    echo "-- База данных: ${DB}" >> /var/backups/postgresql/all_schemas.sql
    echo "\\c ${DB}" >> /var/backups/postgresql/all_schemas.sql
    pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres -s ${DB} >> /var/backups/postgresql/all_schemas.sql
    echo "" >> /var/backups/postgresql/all_schemas.sql
done
```

**Совет:** Самый безопасный вариант - делать **полные бэкапы** (схема + данные) для продакшена, а **раздельные бэкапы** - для специфических задач (миграции, тестирование, частичное восстановление).
<br/>


--------------------------------------------------------------------------------------------
# Создание БД с пустыми таблиц
## требуется создать
```postgresql
 rt_pbx_v2_ext         | rt_pbx   | UTF8      | ru_RU.UTF-8 | ru_RU.UTF-8 |            | libc             |
 rt_pbx_v2_logging_ext | rt_pbx   | UTF8      | ru_RU.UTF-8 | ru_RU.UTF-8 |            | libc             |
 rt_pbx_v2_media_ext   | rt_pbx   | UTF8      | ru_RU.UTF-8 | ru_RU.UTF-8 |            | libc             |
 rt_pbx_v2_stat_ext    | rt_pbx   | UTF8      | ru_RU.UTF-8 | ru_RU.UTF-8 |            | libc             |
```

## Проверка исходных БД
```bash
# Посмотреть что сейчас в исходных БД
echo "=== Таблицы в исходных БД ==="
for DB in rt_pbx_v2_71 rt_pbx_v2_logging_71 rt_pbx_v2_media_71 rt_pbx_v2_stat_71; do
    echo "БД: $DB"
    psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d $DB -c "SELECT COUNT(*) as table_count FROM pg_tables WHERE schemaname = 'public';"
done
```

## Создать пустые БД 
```bash
# Создаем с ЯВНЫМ указанием template0
for DB in rt_pbx_v2_ext rt_pbx_v2_logging_ext rt_pbx_v2_media_ext rt_pbx_v2_stat_ext; do
    echo "Создаю АБСОЛЮТНО пустую БД: $DB"
    psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c \
        "CREATE DATABASE $DB 
        WITH 
        OWNER = rt_pbx 
        ENCODING = 'UTF8' 
        LC_COLLATE = 'ru_RU.UTF-8' 
        LC_CTYPE = 'ru_RU.UTF-8' 
        TEMPLATE = template0 
        ALLOW_CONNECTIONS = true;"
done
```

## Создать БД с пустыми таблицами
```bash
# Создаем каждую БД отдельной командой
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "CREATE DATABASE rt_pbx_v2_ext WITH OWNER = rt_pbx ENCODING = 'UTF8' LC_COLLATE = 'ru_RU.UTF-8' LC_CTYPE = 'ru_RU.UTF-8' TEMPLATE = template0;"

psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "CREATE DATABASE rt_pbx_v2_logging_ext WITH OWNER = rt_pbx ENCODING = 'UTF8' LC_COLLATE = 'ru_RU.UTF-8' LC_CTYPE = 'ru_RU.UTF-8' TEMPLATE = template0;"

psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "CREATE DATABASE rt_pbx_v2_media_ext WITH OWNER = rt_pbx ENCODING = 'UTF8' LC_COLLATE = 'ru_RU.UTF-8' LC_CTYPE = 'ru_RU.UTF-8' TEMPLATE = template0;"

psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "CREATE DATABASE rt_pbx_v2_stat_ext WITH OWNER = rt_pbx ENCODING = 'UTF8' LC_COLLATE = 'ru_RU.UTF-8' LC_CTYPE = 'ru_RU.UTF-8' TEMPLATE = template0;"

# или через цикл создать 
for DB in rt_pbx_v2_ext rt_pbx_v2_logging_ext rt_pbx_v2_media_ext rt_pbx_v2_stat_ext; do
    echo "Создаю БД: $DB"
    psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c \
        "CREATE DATABASE $DB WITH OWNER = rt_pbx ENCODING = 'UTF8' LC_COLLATE = 'ru_RU.UTF-8' LC_CTYPE = 'ru_RU.UTF-8' TEMPLATE = template0;"
done
```

## Проверка полученных БД
```bash
# Проверить - таблиц не должно быть
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d rt_pbx_v2_ext -c "\dt"
# Должно быть: "Не найдено отношений."

psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d rt_pbx_v2_logging_ext -c "\dt"
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d rt_pbx_v2_media_ext -c "\dt"
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d rt_pbx_v2_stat_ext -c "\dt"

# Проверить что таблиц нет (должны быть пустые)
for DB in rt_pbx_v2_ext rt_pbx_v2_logging_ext rt_pbx_v2_media_ext rt_pbx_v2_stat_ext; do
    echo "=== Проверка БД: $DB ==="
    psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d $DB -c "\dt+"
done

# Посмотреть что будет в новых БД (пустые)
echo "=== Что будет в новых БД ==="
for DB in rt_pbx_v2_ext rt_pbx_v2_logging_ext rt_pbx_v2_media_ext rt_pbx_v2_stat_ext; do
    echo "БД: $DB (будет создана)"
    echo "  - 0 таблиц (абсолютно пустая)"
done

# Проверить список всех БД
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "\l" | grep -E "(Name|_ext)"
```

## Дополнительная проверка через SQL
```bash
# Подробная проверка всех созданных БД
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "
SELECT 
    d.datname as \"База данных\",
    pg_size_pretty(pg_database_size(d.datname)) as \"Размер\",
    (SELECT COUNT(*) FROM pg_tables WHERE schemaname NOT IN ('pg_catalog', 'information_schema')) as \"Таблиц\",
    (SELECT COUNT(*) FROM pg_views WHERE schemaname NOT IN ('pg_catalog', 'information_schema')) as \"Представлений\",
    (SELECT COUNT(*) FROM pg_indexes WHERE schemaname NOT IN ('pg_catalog', 'information_schema')) as \"Индексов\"
FROM pg_database d
WHERE d.datname LIKE '%_ext'
ORDER BY d.datname;
"

# Или подробнее
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "
SELECT 
    datname as \"База данных\",
    datdba::regrole as \"Владелец\",
    pg_size_pretty(pg_database_size(datname)) as \"Размер\",
    pg_encoding_to_char(encoding) as \"Кодировка\",
    datcollate as \"Коллация\"
FROM pg_database 
WHERE datname LIKE '%_ext'
ORDER BY datname;
"


# Этот запрос проверяет таблицы в КОНКРЕТНОЙ БД
echo "=== ПРАВИЛЬНАЯ ПРОВЕРКА ==="

for DB in rt_pbx_v2_ext rt_pbx_v2_logging_ext rt_pbx_v2_media_ext rt_pbx_v2_stat_ext; do
    echo ""
    echo "--- БД: $DB ---"
    
    # Проверяем таблицы ВНУТРИ этой БД
    TABLES=$(psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d $DB -t -c \
        "SELECT COUNT(*) FROM pg_tables WHERE schemaname NOT IN ('pg_catalog', 'information_schema');")
    
    # Проверяем таблицы в публичной схеме
    PUBLIC_TABLES=$(psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d $DB -t -c \
        "SELECT COUNT(*) FROM pg_tables WHERE schemaname = 'public';")
    
    # Проверяем список всех таблиц
    echo "Всего таблиц (не системных): $TABLES"
    echo "Таблиц в схеме public: $PUBLIC_TABLES"
    
    if [ "$TABLES" -eq 0 ]; then
        echo "✓ БД АБСОЛЮТНО пустая!"
    else
        echo "✗ Есть таблицы:"
        psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -d $DB -c "\dt"
    fi
done
```


## Если нужно удалить и пересоздать (если уже созданы с ошибкой)
```bash
# Сначала удалить если существуют
for DB in rt_pbx_v2_ext rt_pbx_v2_logging_ext rt_pbx_v2_media_ext rt_pbx_v2_stat_ext; do
    psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "DROP DATABASE IF EXISTS $DB;"
done

# Затем создать заново
for DB in rt_pbx_v2_ext rt_pbx_v2_logging_ext rt_pbx_v2_media_ext rt_pbx_v2_stat_ext; do
    psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c \
        "CREATE DATABASE $DB WITH OWNER = rt_pbx ENCODING = 'UTF8' LC_COLLATE = 'ru_RU.UTF-8' LC_CTYPE = 'ru_RU.UTF-8' TEMPLATE = template0;"
done
```

## Дополнительно: Установить комментарий к БД (опционально)
```bash
for DB in rt_pbx_v2_ext rt_pbx_v2_logging_ext rt_pbx_v2_media_ext rt_pbx_v2_stat_ext; do
    psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c \
        "COMMENT ON DATABASE $DB IS 'Пустая БД для тестирования, создана $(date)';"
done

# Проверить комментарии
psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c "
SELECT 
    datname as database,
    pg_size_pretty(pg_database_size(datname)) as size,
    obj_description(oid, 'pg_database') as comment
FROM pg_database 
WHERE datname LIKE '%_ext';
"
```

## Если на одной из нод БД не среплицировалась

### Создать БД на app3 через временное переключение в мастер:
```bash
# Временный switchover на app3
patronictl -c /etc/patroni/config.yml switchover --master app --candidate app3 --force

# Создать БД на app3 (теперь он мастер)
for DB in rt_pbx_v2_ext rt_pbx_v2_logging_ext rt_pbx_v2_media_ext rt_pbx_v2_stat_ext; do
    ssh root@192.168.87.62 "psql -h /var/lib/postgresql/patroni -p 5433 -U postgres -c \
        'CREATE DATABASE IF NOT EXISTS $DB WITH OWNER = rt_pbx ENCODING = \"UTF8\" \
        LC_COLLATE = \"ru_RU.UTF-8\" LC_CTYPE = \"ru_RU.UTF-8\" TEMPLATE = template0;'"
done

# Вернуть мастер на app
patronictl -c /etc/patroni/config.yml switchover --master app3 --candidate app --force
```

### Скопировать БД с app2 на app3
```bash
# На app2 сделать дампы БД
ssh root@192.168.87.61 "mkdir -p /tmp/db_dump"
for DB in rt_pbx_v2_ext rt_pbx_v2_logging_ext rt_pbx_v2_media_ext rt_pbx_v2_stat_ext; do
    ssh root@192.168.87.61 "pg_dump -h /var/lib/postgresql/patroni -p 5433 -U postgres -s -Fc -f /tmp/db_dump/${DB}.dump $DB"
done

# Скопировать на app3
scp root@192.168.87.61:/tmp/db_dump/*.dump /tmp/

# На app3 восстановить (если сможет - но он реплика!)
# Это может не сработать из-за режима только чтение
```
<br/>

--------------------------------------------------------------------

## Если требуется создать пароль для пользователя rt_pbx
```bash
# Подключитесь к мастеру
sudo -u postgres psql -p 5433 -h 192.168.87.60

-- Установите пароль для rt_pbx
ALTER USER rt_pbx WITH PASSWORD 'ваш_пароль';
```
или записать в файл **`/var/lib/postgresql/.pgpass`**:
```bash
hostname:port:database:username:password

192.168.87.60:5433:*:rt_pbx:ваш_пароль
```


