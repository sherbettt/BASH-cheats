Таблица `iptables` — это мощный инструмент Linux для управления сетевыми пакетами, фильтрации трафика и NAT-трансляций. Давайте разберём её структуру и порядок обработки пакетов.

## Таблицы и цепи

### Основные таблицы (`tables`)

1. **filter**  
   Основная таблица для фильтрации входящего/исходящего трафика.
   
2. **nat**  
   Используется для трансляции адресов (NAT), переадресации портов и изменения исходящих IP-адресов.

3. **mangle**  
   Применяется для модификации полей заголовков пакета (например, TTL, Type of Service).

4. **raw**  
   Специальная таблица для пометки пакетов перед обработкой остальными таблицами.

### Цепочки (`chains`) внутри каждой таблицы

Каждая таблица имеет свою специфику цепей:

#### Таблица filter
- **INPUT**: пакеты, предназначенные локальному хосту (входящие).
- **OUTPUT**: пакеты от локального хоста (исходящие).
- **FORWARD**: транзитные пакеты, проходящие через машину.

#### Таблица nat
- **PREROUTING**: применяется до маршрута принимаемых пакетов (DNAT, изменение целевого адреса).  
- **POSTROUTING**: используется после маршрутизации отправляемых пакетов (SNAT, изменение исходящего адреса).  
- **OUTPUT**: применяется для локально генерируемых пакетов (используется редко).

#### Таблица mangle
- **PREROUTING**: применяемые правила перед маршрутом входящих пакетов.  
- **POSTROUTING**: применяются после маршрутизации исходящих пакетов.  
- **INPUT**, **OUTPUT**, **FORWARD**: используются реже, поскольку чаще всего модификация ограничивается изменениями, касающимися маршрутизации.

## Порядок прохождения цепей для различных типов пакетов

Рассмотрим процесс обработки пакета поэтапно:

### Входящий трафик
1. Интерфейс → Raw → Mangle → Nat (PREROUTING) → Routing decision → Filter (INPUT)
2. Если принятый пакет предназначен для другого интерфейса, добавляется этап: Mangle → Filter (FORWARD) → Nat (POSTROUTING) → Interface.

### Исходящий трафик
1. Local process → Raw → Mangle → Nat (OUTPUT) → Routing decision → Mangle → Nat (POSTROUTING) → Interface.

Таким образом, таблица `mangle`, вместе с таблицей `nat`, участвует в обработке каждого типа пакетов, позволяя изменять различные аспекты сети, такие как QoS (качество обслуживания), журналирование и оптимизацию маршрутов.

---

### Итоги

Итак, структура таблицы выглядит следующим образом:

| Table     | Chains               |
|-----------|----------------------|
| filter    | INPUT, OUTPUT, FORWARD|
| nat       | PREROUTING, POSTROUTING, OUTPUT |
| mangle    | PREROUTING, POSTROUTING, INPUT, OUTPUT, FORWARD |
| raw       | PREROUTING, OUTPUT   |

Порядок прохождения цепей зависит от направления движения пакетов, обеспечивая гибкость и детализированность контроля над сетевым трафиком.

Давайте подробно рассмотрим каждую составляющую схемы обработки сетевых пакетов в Linux с использованием инструмента `iptables`.

## Таблицы и их назначение

1. **Table `filter`:**
   Эта таблица предназначена для основного процесса фильтрации трафика и принятия решений о пропускании или блокировании пакетов. Она обрабатывает три ключевые цепочки:
   - **INPUT:** обработка поступающих пакетов, предназначенных для локальной машины.
   - **OUTPUT:** обработка исходящих пакетов, созданных самой системой.
   - **FORWARD:** обработка транзитных пакетов, проходящих через систему между интерфейсами.

2. **Table `nat`:**
   Использует механизм Network Address Translation (NAT), позволяющий менять IP-адреса и порты. Имеет следующие цепочки:
   - **PREROUTING:** принимает решение до выбора маршрута для входящих пакетов (Destination NAT — DNAT, меняется целевой адрес).
   - **POSTROUTING:** применяется после определения маршрута для исходящих пакетов (Source NAT — SNAT, изменяется исходящий адрес).
   - **OUTPUT:** применяется для пакетов, создаваемых самим сервером (редко используется).

3. **Table `mangle`:**
   Используется для изменения различных свойств пакетов, таких как поля заголовков, маркировка (marking), время жизни (TTL), приоритет и другие. Здесь находятся такие же цепочки, как и в таблице `filter`:
   - **PREROUTING:** для входящих пакетов перед выбором маршрута.
   - **POSTROUTING:** для исходящих пакетов после выбора маршрута.
   - **INPUT:** для поступивших пакетов, которые остаются на данной машине.
   - **OUTPUT:** для пакетов, генерируемых машиной.
   - **FORWARD:** для транзитных пакетов.

4. **Table `raw`:**
   Предназначается для предварительной обработки пакетов до всех остальных таблиц. Её цель — поставить метки на пакеты, влияющие на дальнейшую обработку.

## Последовательность обработки цепей

Чтобы лучше понять весь процесс, давайте представим шаги, которые проходит пакет, начиная с момента поступления на сетевую карту и заканчивая выходом наружу либо доставкой внутрь системы.

### Поступающий пакет ("inbound")
1. Пакет поступает на физический интерфейс устройства.
2. Прежде всего, пакет попадает в таблицу `raw`. Здесь можно добавить специальные отметки (маркировки), используемые позже для дальнейшей обработки.
3. Затем идёт обработка таблицы `mangle`, цепь `PREROUTING`, где возможно изменить некоторые свойства пакета, например TOS или TTL.
4. Далее обрабатывается таблица `nat`, цепь `PREROUTING`. Здесь выполняется Destination NAT (изменение цели назначения пакета), если оно требуется.
5. После этого принимается решение о маршрутизации (Routing Decision):
   - Если пакет направлен на саму машину, он переходит в таблицу `filter`, цепь `INPUT`.
   - Если пакет транзитом направляется дальше, он отправляется на следующую фазу обработки, минуя таблицу `filter`.
6. В конце концов, если это транзитный пакет, он продолжает двигаться дальше:
   - Опять проходит через таблицу `mangle`, цепь `FORWARD`.
   - Затем снова попадает в таблицу `filter`, цепь `FORWARD`.
7. Наконец, пакет выходит через таблицу `nat`, цепь `POSTROUTING`, где производится Source NAT (при необходимости изменений исходящего адреса).
8. Последний этап — выход через интерфейс.

### Исходящий пакет ("outbound")
1. Локальное приложение создаёт пакет и отправляет его в сеть.
2. Сначала пакет попадает в таблицу `raw`, цепь `OUTPUT`, где возможна предварительная отметка пакета.
3. Следующий шаг — таблица `mangle`, цепь `OUTPUT`, где опять-таки возможны небольшие изменения некоторых параметров.
4. Дальше пакет обрабатывается в таблице `nat`, цепь `OUTPUT`, где иногда применяют Source NAT для локальных приложений.
5. Выполняется процедура выбора маршрута (Routing Decision).
6. Теперь наступает очередь таблицы `mangle`, цепь `POSTROUTING`, где ещё раз проверяются и меняются необходимые параметры.
7. Заключительный этап — таблица `nat`, цепь `POSTROUTING`, где осуществляется финальная проверка Source NAT.
8. Затем пакет покидает устройство через нужный интерфейс.

## Детали конкретных цепей

Теперь немного подробнее о каждом этапе:

### Чейн `PREROUTING`
Этот чейн активируется сразу после приёма пакета устройством и перед определением маршрута. Это важный этап, особенно для реализации правил NAT (Destination NAT), которые меняют конечный пункт доставки пакета.

Например, допустим, у вас настроено правило, перенаправляющее входящие запросы на определённый внутренний сервис. Тогда именно здесь определяется новый адрес назначения.

### Чейн `POSTROUTING`
Эта фаза запускается после выбора маршрута и непосредственно перед передачей пакета следующему узлу сети. Обычно на данном этапе применяется Source NAT, когда внешний IP-адрес заменяется внутренним адресом устройства (или наоборот).

Это позволяет отправлять внутренние запросы, скрывая реальный источник трафика, предоставляя возможность прозрачной связи с внешним миром даже из частной сети.

### Таблица `mangle`
Хотя часто этот этап игнорируют, именно тут можно вносить тонкие настройки поведения пакетов. Например, установить маркировку (mark), которая потом позволит применять приоритеты QOS или направлять пакеты по различным каналам в зависимости от нагрузки.

Пример использования — изменение Time To Live (TTL) или установки особых приоритетов для VoIP-трафика.

### Дополнительные моменты
Стоит помнить, что каждый пакет последовательно проходит через несколько этапов обработки, и каждая операция накладывает дополнительные задержки. Поэтому важно аккуратно настраивать правила, минимизируя количество проверок и операций, чтобы избежать ненужных задержек и повышения нагрузки на систему.


### Резюме

Процесс обработки сетевых пакетов через систему `iptables` включает прохождение нескольких стадий: сначала выполняется ранняя маркировка, затем определяются маршруты и применяются операции NAT, далее происходят манипуляции с параметрами пакетов и принятие решения о прохождении фильтра. Каждый этап важен и влияет на поведение всей системы, будь то безопасность, производительность или качество сервиса.

--------------------

В Linux таблицы iptables хранятся в памяти ядра, а не в файлах. Однако вы можете просмотреть и сохранить текущие правила несколькими способами:

### Важные предупреждения

1. **Всегда настраивайте правила через консоль, к которой есть физический доступ** или через out-of-band управление
2. **Сначала добавляйте правило разрешения для SSH**, прежде чем блокировать входной трафик
3. **Тестируйте правила постепенно**
4. **Используйте политику ACCEPT по умолчанию при настройке**, меняя на DROP только после проверки всех правил



## Практическое управление iptables

### Просмотр правил

**1. Основные команды просмотра:**
```bash
# Просмотр таблицы filter (по умолчанию)
iptables -L

# Подробный просмотр с адресами и интерфейсами
iptables -nL

# Просмотр с количеством обработанных пакетов и байтов
iptables -nvL

# Просмотр с номерами строк (CRITICAL для управления!)
iptables -nL --line-numbers

# Просмотр всех таблиц
iptables-save
```

**2. Просмотр конкретных таблиц:**
```bash
# Для таблицы nat
iptables -t nat -nvL

# Для таблицы mangle
iptables -t mangle -nvL

# Для таблицы raw
iptables -t raw -nvL
```

### Добавление правил

**Базовый синтаксис:**
```bash
iptables [-t таблица] -A цепочка [условия] -j действие
```

**Примеры добавления правил:**

```bash
# Разрешить SSH (порт 22)
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# Заблокировать конкретный IP
iptables -A INPUT -s 192.168.1.100 -j DROP

# Разрешить исходящие HTTPS запросы
iptables -A OUTPUT -p tcp --dport 443 -j ACCEPT

# Добавить правило в начало цепочки (вместо -A используем -I)
iptables -I INPUT 1 -p tcp --dport 80 -j ACCEPT

# NAT правило для проброса портов (DNAT)
iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 192.168.1.10:80

# Source NAT для исходящего трафика
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
```

### Удаление правил

**1. Удаление по номеру строки:**
```bash
# Сначала смотрим правила с номерами
iptables -nL --line-numbers

# Удаляем правило №3 из цепочки INPUT
iptables -D INPUT 3
```

**2. Удаление по точному совпадению:**
```bash
# Удаляем правило, идентичное добавляемому
iptables -D INPUT -p tcp --dport 22 -j ACCEPT
```

**3. Очистка всех правил в цепочке:**
```bash
# Очистить все правила в цепочке INPUT
iptables -F INPUT

# Очистить ВСЕ цепочки во ВСЕХ таблицах
iptables -F
```

### Управление политиками по умолчанию

**Установка политик по умолчанию (DEFAULT POLICY):**
```bash
# Блокировать весь входящий трафик по умолчанию
iptables -P INPUT DROP

# Разрешить весь исходящий трафик по умолчанию
iptables -P OUTPUT ACCEPT

# Блокировать транзитный трафик
iptables -P FORWARD DROP
```

**Внимание!** Будьте осторожны с политикой DROP - можно заблокировать себя от сервера!

### Создание пользовательских цепочек

```bash
# Создать пользовательскую цепочку
iptables -N MY_CHAIN

# Добавить правило, ссылающееся на пользовательскую цепочку
iptables -A INPUT -p tcp --dport 8080 -j MY_CHAIN

# Добавить правила в пользовательскую цепочку
iptables -A MY_CHAIN -s 192.168.1.0/24 -j ACCEPT
iptables -A MY_CHAIN -j DROP
```

### Практические примеры настройки

**Базовый безопасный конфигурационный файл:**
```bash
#!/bin/bash

# Очистка всех правил
iptables -F
iptables -t nat -F
iptables -t mangle -F

# Установка политик по умолчанию
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Разрешить loopback интерфейс
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# Разрешить установленные соединения
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Разрешить SSH
iptables -A INPUT -p tcp --dport 22 -j ACCEPT

# Разрешить HTTP/HTTPS
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# Разрешить ping
iptables -A INPUT -p icmp -j ACCEPT

# Логирование отклоненных пакетов (опционально)
iptables -A INPUT -j LOG --log-prefix "IPTABLES-DROPPED: "
```

### Сохранение и восстановление правил

**Сохранение текущих правил:**
```bash
# Сохранить в файл
iptables-save > /etc/iptables/rules.v4

# Для IPv6
ip6tables-save > /etc/iptables/rules.v6
```

**Восстановление правил:**
```bash
# Восстановить из файла
iptables-restore < /etc/iptables/rules.v4
```

**Автозагрузка правил при старте системы:**
```bash
# Установка пакета для сохранения правил (Debian/Ubuntu)
apt install iptables-persistent

# Сохранение текущих правил
netfilter-persistent save
```

### Полезные команды для отладки

```bash
# Просмотр правил с счетчиками
iptables -nvL

# Сброс счетчиков
iptables -Z

# Мониторинг в реальном времени
watch -n 1 'iptables -nvL'

# Проверка конкретного правила
iptables -C INPUT -p tcp --dport 22 -j ACCEPT
echo $?  # 0 - правило существует, 1 - не существует
```

------------------------------------------------

**Полная расшифровка команды:**
```
iptables -A FORWARD -s 192.168.46.0/24 -d 192.168.87.0/24 -j ACCEPT
```

Разберем ее по частям:

*   **`iptables`**: Утилита для настройки правил межсетевого экрана (фаервола) в Linux.
*   **`-A FORWARD`**:
    *   `-A` — означает **Append** (добавить). Это добавляет новое правило в конец цепочки.
    *   `FORWARD` — это имя цепочки. Цепочка `FORWARD` отвечает за трафик, который **проходит через** сервер (роутер, шлюз), но не предназначен для него самого (не является получателем или отправителем).
*   **`-s 192.168.46.0/24`**:
    *   `-s` — означает **source** (источник). Это IP-адрес или сеть, откуда пришел пакет.
    *   `192.168.46.0/24` — это обозначение сети. `/24` означает маску подсети `255.255.255.0`. То есть, это весь диапазон IP-адресов от `192.168.46.1` до `192.168.46.254`.
*   **`-d 192.168.87.0/24`**:
    *   `-d` — означает **destination** (назначение). Это IP-адрес или сеть, куда направлен пакет.
    *   `192.168.87.0/24` — аналогично, это сеть, включающая адреса от `192.168.87.1` до `192.168.87.254`.
*   **`-j ACCEPT`**:
    *   `-j` — означает **jump** (переход). Это действие, которое нужно выполнить с пакетом, если он соответствует правилу.
    *   `ACCEPT` — действие "**принять**" пакет и позволить ему продолжить путь.



### Простым языком:

**"Разрешить весь трафик, который идет из сети `192.168.46.0/24` в сеть `192.168.87.0/24`, через этот сервер/роутер."**

### Типичный сценарий использования:

Это правило чаще всего настраивается на **роутере** или **шлюзе**, который соединяет две разные сети.
*   С одной стороны у него есть сеть `192.168.46.0/24`.
*   С другой стороны — сеть `192.168.87.0/24`.

Без этого правила (или подобного ему) компьютеры из одной сети не смогли бы общаться с компьютерами из другой сети, так как фаервол по умолчанию блокирует весь трафик.

### Важные нюансы:

1.  **Одностороннее правило**: Это правило разрешает трафик только в одном направлении: **из `192.168.46.0/24` в `192.168.87.0/24`**. Для ответного трафика (из `192.168.87.0/24` в `192.168.46.0/24`) потребуется либо зеркальное правило, либо правило, разрешающее установленные соединения.
2.  **Порядок правил**: `iptables` проверяет правила по порядку. Поскольку использовался флаг `-A` (добавить в конец), это правило будет проверяться после всех правил, которые были добавлены в цепочку `FORWARD` ранее. Если перед ним есть правило с действием `DROP` или `REJECT`, которое блокирует этот трафик, то данное правило `ACCEPT` не сработает.

**Итог:** Данная команда — это базовое правило маршрутизации и фильтрации, которое позволяет компьютерам из одной подсети обращаться к компьютерам в другой подсете через устройство, на котором оно применено.
