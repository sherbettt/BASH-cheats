# Правильная работа с Systemd Unit файлами

## Иерархия приоритетов systemd

```
/etc/systemd/system/    ←  ВЫСШИЙ ПРИОРИТЕТ (пользовательские настройки)
/run/systemd/system/    ←  СРЕДНИЙ ПРИОРИТЕТ (временные настройки)  
/lib/systemd/system/    ←  НИЗШИЙ ПРИОРИТЕТ (системные пакеты)
```

## Правильные способы создания и редактирования unit файлов

### **Способ 1: Через `systemctl edit` (РЕКОМЕНДУЕТСЯ)**
```bash
# Создает override конфиг в правильной директории
systemctl edit haproxy

# Автоматически создает:
# /etc/systemd/system/haproxy.service.d/override.conf
```

### **Способ 2: Ручное создание override**
```bash
# Создаем директорию для override
mkdir -p /etc/systemd/system/haproxy.service.d/

# Создаем файл override
mcedit /etc/systemd/system/haproxy.service.d/override.conf
```

### **Способ 3: Полная замена unit (редкие случаи)**
```bash
# Копируем оригинальный unit для модификации
cp /lib/systemd/system/haproxy.service /etc/systemd/system/haproxy.service

# Редактируем полную копию
mcedit /etc/systemd/system/haproxy.service
```

## Что можно и нужно переопределять в override

### **✅ МОЖНО и НУЖНО переопределять:**

#### **1. Лимиты ресурсов**
```ini
[Service]
LimitNOFILE=65536
LimitNPROC=4096
LimitMEMLOCK=infinity
```

#### **2. Переменные окружения**
```ini
[Service]
Environment=CONFIG=/etc/haproxy/haproxy.cfg
Environment=PIDFILE=/run/haproxy.pid
Environment=EXTRAOPTS="-S /run/haproxy-master.sock"
```

#### **3. Параметры безопасности**
```ini
[Service]
NoNewPrivileges=true
ProtectHome=true
ProtectSystem=strict
```

#### **4. Таймауты и перезапуски**
```ini
[Service]
TimeoutStartSec=300
TimeoutStopSec=30
Restart=always
RestartSec=5
```

#### **5. Пользователь и группа**
```ini
[Service]
User=_haproxy
Group=_haproxy
```

### **❌ НЕЛЬЗЯ переопределять (или нужно осторожно):**

#### **1. Имя службы и описание**
```ini
# ❌ НЕ РАБОТАЕТ в override:
[Unit]
Description=My Custom HAProxy  # ← не применится
```

#### **2. Основные Exec команды (лучше через переменные)**
```ini
# ❌ ПЛОХО - полностью меняет логику:
ExecStart=/usr/local/sbin/haproxy -my-custom-flags  # ← может сломать обновления

# ✅ ХОРОШО - через переменные:
Environment=EXTRAOPTS="-my-custom-flags"
ExecStart=/usr/sbin/haproxy -Ws -f $CONFIG -p $PIDFILE $EXTRAOPTS
```

#### **3. Зависимости между юнитами**
```ini
# ❌ Может нарушить системные зависимости:
[Unit]
Wants=network-online.target
After=network.target
```

## Практические примеры правильных override

### **Пример 1: Увеличение лимитов для HAProxy**
```ini
[Service]
# Лимиты файловых дескрипторов
LimitNOFILE=65536

# Лимиты памяти
LimitMEMLOCK=infinity

# Дополнительные переменные
Environment=EXTRAOPTS="-S /run/haproxy-master.sock"
```

### **Пример 2: Настройка перезапусков**
```ini
[Service]
# Политика перезапуска
Restart=always
RestartSec=5

# Таймауты
TimeoutStartSec=300
TimeoutStopSec=30

# Лимиты процессов
LimitNPROC=4096
```

### **Пример 3: Безопасность и изоляция**
```ini
[Service]
# Безопасность
NoNewPrivileges=true
ProtectHome=true
ProtectSystem=strict

# Файловые системы
ReadWritePaths=/var/lib/haproxy
ReadOnlyPaths=/etc/haproxy
```

## Проверка и отладка unit файлов

### **Просмотр итоговой конфигурации**
```bash
# Показать ВСЕ примененные конфиги
systemctl cat haproxy.service

# Показать пути к конфигам
systemctl show haproxy -p FragmentPath,DropInPaths

# Показать конкретные параметры
systemctl show haproxy -p LimitNOFILE,Restart,Environment
```

### **Проверка синтаксиса**
```bash
# Проверить синтаксис unit файла
systemd-analyze verify /etc/systemd/system/haproxy.service.d/override.conf

# Проверить все unit файлы службы
systemd-analyze verify /lib/systemd/system/haproxy.service /etc/systemd/system/haproxy.service.d/override.conf
```

### **Отладка зависимостей**
```bash
# Показать зависимости
systemctl list-dependencies haproxy.service

# Показать что блокирует запуск
systemctl --failed
```

## Частые ошибки и их решения

### **❌ ОШИБКА: Редактирование /lib/systemd/system/**
```bash
# ❌ НЕПРАВИЛЬНО
mcedit /lib/systemd/system/haproxy.service

# ✅ ПРАВИЛЬНО
systemctl edit haproxy
```

### **❌ ОШИБКА: Полное копирование без необходимости**
```bash
# ❌ ИЗБЫТОЧНО
cp /lib/systemd/system/haproxy.service /etc/systemd/system/haproxy.service

# ✅ ДОСТАТОЧНО
systemctl edit haproxy  # только изменения
```

### **❌ ОШИБКА: Использование неправильных секций в override**
```ini
# ❌ НЕ РАБОТАЕТ в override:
[Unit]
Description=My Service  # ← не применится

[Install]  
WantedBy=multi-user.target  # ← не применится

# ✅ РАБОТАЕТ в override:
[Service]
LimitNOFILE=65536  # ← применится
Environment=DEBUG=1  # ← применится
```

## Best Practices

### **1. Всегда используйте `systemctl edit`**
```bash
# Автоматически создает правильную структуру
systemctl edit service-name
```

### **2. Минимальные изменения**
```ini
# Изменяйте только то, что действительно нужно
[Service]
LimitNOFILE=65536
# Остальное оставьте как в оригинальном unit
```

### **3. Сохраняйте совместимость**
```ini
# Используйте переменные вместо жестких путей
Environment=CONFIG=/etc/haproxy/haproxy.cfg
ExecStart=/usr/sbin/haproxy -Ws -f $CONFIG
```

### **4. Документируйте изменения**
```ini
# Custom limits for high-load PostgreSQL
[Service]
LimitNOFILE=65536    # Allow 65k concurrent connections
LimitMEMLOCK=infinity # Required for large buffers
```

### **5. Тестируйте после изменений**
```bash
# Применить изменения
systemctl daemon-reload

# Проверить службу
systemctl status service-name

# Протестировать запуск/остановку
systemctl restart service-name
```

## Итоговый чеклист

- ✅ **Используйте** `/etc/systemd/system/` для пользовательских настроек
- ✅ **Применяйте** `systemctl edit` для создания override
- ✅ **Изменяйте** только параметры `[Service]` в override
- ✅ **Сохраняйте** совместимость с оригинальным unit
- ✅ **Тестируйте** изменения перед применением в production
- ✅ **Документируйте** нестандартные настройки
- ❌ **Не редактируйте** файлы в `/lib/systemd/system/`
- ❌ **Не копируйте** полные unit файлы без необходимости
- ❌ **Не изменяйте** секции `[Unit]` и `[Install]` в override

------------------------------------------------------------------------

# Пошаговая инструкция создания собственного systemd unit

## 1. Создание файла сервиса

```bash
# Переходим в директорию systemd
cd /etc/systemd/system/

# Создаем файл сервиса (замените my-service на имя вашего сервиса)
sudo nano my-service.service
```

## 2. Базовая структура сервисного файла

```ini
[Unit]
Description=My Custom Service
Documentation=https://example.com/docs
After=network.target

[Service]
Type=simple
User=myuser
Group=mygroup
WorkingDirectory=/path/to/working/directory
ExecStart=/usr/bin/python3 /path/to/script.py
ExecReload=/bin/kill -HUP $MAINPID
Restart=on-failure
RestartSec=5s

[Install]
WantedBy=multi-user.target
```

## 3. Подробный пример с комментариями

```ini
[Unit]
# Описание сервиса
Description=My Custom Web Application

# Документация (опционально)
Documentation=man:myapp(8) https://myapp.com/docs

# Зависимости - запускать после этих сервисов
After=network.target nginx.service
Wants=nginx.service

# Условия запуска (опционально)
ConditionPathExists=/var/lib/myapp/config.json

[Service]
# Тип сервиса:
# simple - основной процесс становится сервисом
# forking - процесс порождает дочерний и завершается
# oneshot - выполняется один раз
Type=simple

# Пользователь и группа от которых запускать
User=www-data
Group=www-data

# Рабочая директория
WorkingDirectory=/var/www/myapp

# Команда запуска
ExecStart=/usr/bin/python3 app.py --port 8080

# Команда перезагрузки (опционально)
ExecReload=/bin/kill -HUP $MAINPID

# Команда остановки (опционально)
ExecStop=/bin/kill -TERM $MAINPID

# Перезапуск при сбое
Restart=on-failure
RestartSec=10s

# Таймаут остановки (секунды)
TimeoutStopSec=5

# Переменные окружения (опционально)
Environment=DEBUG=false
EnvironmentFile=/etc/myapp/env.conf

# Лимиты ресурсов (опционально)
LimitNOFILE=65536
MemoryLimit=512M

[Install]
# В каких целях должен быть включен сервис
WantedBy=multi-user.target
```

## 4. Практический пример для Python приложения

```ini
[Unit]
Description=Python Web API Service
After=network.target postgresql.service
Wants=postgresql.service

[Service]
Type=simple
User=api
Group=api
WorkingDirectory=/opt/myapi
Environment=PYTHONPATH=/opt/myapi
Environment=DB_HOST=localhost
ExecStart=/usr/bin/python3 -u main.py
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=3
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
```

## 5. Действия после создания файла

```bash
# Перезагружаем демон systemd
sudo systemctl daemon-reload

# Включаем автозапуск при загрузке
sudo systemctl enable my-service.service

# Запускаем сервис
sudo systemctl start my-service.service

# Проверяем статус
sudo systemctl status my-service.service

# Просмотр логов
sudo journalctl -u my-service.service -f
```

## 6. Полезные команды для управления

```bash
# Остановка сервиса
sudo systemctl stop my-service.service

# Перезапуск сервиса
sudo systemctl restart my-service.service

# Перезагрузка конфигурации
sudo systemctl reload my-service.service

# Отключение автозапуска
sudo systemctl disable my-service.service

# Проверка синтаксиса файла (требуется systemd-analyze)
sudo systemd-analyze verify /etc/systemd/system/my-service.service
```

## 7. Создание пользовательского юнита для конкретных случаев

### Для скрипта Bash:
```ini
[Unit]
Description=Backup Script Service
After=network.target

[Service]
Type=oneshot
User=backup
ExecStart=/usr/local/bin/backup.sh
StandardOutput=journal
StandardError=journal
```

### Для демона с несколькими процессами:
```ini
[Unit]
Description=Worker Pool Service

[Service]
Type=forking
User=worker
ExecStart=/usr/local/bin/worker-pool --daemon
PIDFile=/var/run/worker-pool.pid
Restart=always
```

## Важные замечания:

1. **Права доступа**: Убедитесь, что у файла правильные права (644)
2. **Пользователь**: Создайте отдельного пользователя для сервиса если нужно
3. **Логи**: Используйте `journalctl` для просмотра логов
4. **Тестирование**: Всегда тестируйте сервис перед включением в автозагрузку
5. **Безопасность**: Минимизируйте привилегии сервиса

------------------------------------------------------------------------

# Создание сложного Systemd Unit с нуля

## Когда нужно создавать свой unit с нуля

**Ситуации требующие кастомного unit:**
- Собственные приложения/сервисы
- Сложные скрипты с зависимостями  
- Docker контейнеры с нетривиальной логикой
- Кастомные мониторинговые агенты
- Сложные системные утилиты

## Структура сложного Systemd Unit

### **Полный пример сложного unit с комментариями**
```ini
[Unit]
# Мета-информация и описание
Description=My Complex Application Server
Documentation=https://github.com/mycompany/myapp  # Ссылка на документацию
Documentation=man:myapp(8)  # Man-страница

# Зависимости - КОГДА запускать
After=network-online.target postgresql.service redis.service  # Запускать ПОСЛЕ этих сервисов
Wants=network-online.target  # Желательные зависимости (не блокирующие)
Requires=postgresql.service  # Обязательные зависимости
Before=nginx.service  # Этот сервис должен запускаться ДО nginx

# Условия запуска - проверки перед запуском
ConditionPathExists=/etc/myapp/config.conf  # Проверить что конфиг существует
ConditionDirectoryNotEmpty=/var/lib/myapp/data  # Проверить что директория не пуста
AssertPathExists=/usr/local/bin/myapp  # Требовать существование бинарника

[Service]
# Тип сервиса - как systemd должен управлять процессом
Type=notify  # Приложение умеет уведомлять systemd о готовности
NotifyAccess=all  # Разрешить все виды уведомлений

# Пользователь и права
User=myapp  # От какого пользователя запускать
Group=myapp  # От какой группы запускать  
UMask=0027  # Маска прав для создаваемых файлов

# Директории и файлы - автоматическое создание и управление
WorkingDirectory=/var/lib/myapp  # Рабочая директория
RuntimeDirectory=myapp  # Автоматически создаст /run/myapp
StateDirectory=myapp  # Автоматически создаст /var/lib/myapp  
CacheDirectory=myapp  # Автоматически создаст /var/cache/myapp
LogsDirectory=myapp  # Автоматически создаст /var/log/myapp

# Основная команда запуска (разбита на несколько строк для читаемости)
ExecStart=/usr/local/bin/myapp \
    --config /etc/myapp/config.conf \
    --log-level info \
    --daemonize

# Команды управления процессом
ExecReload=/bin/kill -HUP $MAINPID  # Как перезагрузить конфиг (SIGHUP)
ExecStop=/bin/kill -TERM $MAINPID  # Как остановить (SIGTERM)  
ExecStopPost=/bin/rm -f /var/run/myapp/pid  # Что делать после остановки

# Политика перезапусков и таймауты
Restart=on-failure  # Перезапускать только при ошибках
RestartSec=5s  # Ждать 5 секунд перед перезапуском
StartLimitInterval=300  # Окно времени для подсчета попыток (5 минут)
StartLimitBurst=5  # Максимум 5 попыток перезапуска в окне
TimeoutStartSec=300  # Максимум 5 минут на запуск
TimeoutStopSec=30  # Максимум 30 секунд на остановку

# Лимиты ресурсов процесса
LimitNOFILE=65536  # Максимум файловых дескрипторов
LimitNPROC=4096  # Максимум процессов
LimitMEMLOCK=infinity  # Снять лимит на locked memory
MemoryMax=2G  # Жесткий лимит памяти
CPUQuota=150%  # Лимит CPU (150% = 1.5 ядра)

# Переменные окружения
Environment=APP_ENV=production  # Статические переменные
Environment=DEBUG=false
EnvironmentFile=/etc/default/myapp  # Загрузить переменные из файла

# Настройки безопасности и изоляции
NoNewPrivileges=true  # Запретить получение новых привилегий
ProtectSystem=strict  # Защита системных файлов
ProtectHome=true  # Изоляция домашних директорий
ReadWritePaths=/var/lib/myapp /var/log/myapp  # Куда можно писать
ReadOnlyPaths=/etc/myapp /usr/local/bin/myapp  # Только чтение
PrivateTmp=true  # Приватный /tmp
ProtectKernelTunables=true  # Защита kernel tunables
ProtectControlGroups=true  # Защита cgroups

# Настройки сокетов
SocketGroup=myapp  # Группа для сокета
SocketMode=0660  # Права на сокет

[Install]
# Когда и как активировать сервис
WantedBy=multi-user.target  # Запускать при multi-user режиме
Also=myapp-socket.service myapp-timer.service  # Связанные сервисы

# Дополнительные алиасы
Alias=myapp.service  # Можно обращаться как myapp.service
```

## Пошаговое создание сложного unit

### **Шаг 1: Создание основного unit файла**
```bash
# Создаем unit файл в правильной директории (/etc/systemd/system/)
sudo mcedit /etc/systemd/system/my-complex-app.service
```

### **Шаг 2: Настройка зависимостей и условий**
```ini
[Unit]
Description=Complex Application with Database Dependencies
After=network.target postgresql.service redis-server.service  # Зависимости по времени
Wants=postgresql.service redis-server.service  # Мягкие зависимости
Requires=network.target  # Жесткие зависимости

# Проверки перед запуском - если условие ложно, сервис не запустится
ConditionPathExists=/etc/myapp/config.yaml  # Файл должен существовать
ConditionPathIsDirectory=/var/lib/myapp  # Должна быть директория
AssertFileNotEmpty=/etc/myapp/secrets.env  # Файл не должен быть пустым
```

### **Шаг 3: Настройка типа сервиса**
```ini
[Service]
# Выбор типа сервиса в зависимости от поведения приложения:

# Для приложений с собственной демонизацией (создают дочерний процесс)
Type=forking
PIDFile=/var/run/myapp/pid  # Где искать PID файл

# ИЛИ для приложений без демонизации (запускаются в foreground)
Type=simple

# ИЛИ для приложений с systemd нотификациями (sd_notify)
Type=notify
NotifyAccess=all  # Какие уведомления разрешены

# ИЛИ для oneshot задач (выполняются и завершаются)
Type=oneshot
RemainAfterExit=yes  # Считать сервис активным после завершения
```

### **Шаг 4: Настройка безопасности и изоляции**
```ini
[Service]
# Пользователь и группа
User=myapp  # Запуск от конкретного пользователя
Group=myapp
DynamicUser=yes  # Автоматическое создание временного пользователя

# Файловая система
WorkingDirectory=/var/lib/myapp  # Рабочая директория
RootDirectory=/srv/myapp/chroot  # Chroot окружение
ReadWritePaths=/var/lib/myapp /var/log/myapp  # Пути с доступом на запись
ReadOnlyPaths=/etc/myapp /usr/lib/myapp  # Пути только для чтения
InaccessiblePaths=/proc/sys /sys/kernel  # Полностью заблокированные пути

# Безопасность процесса
NoNewPrivileges=true  # Запретить escalation привилегий
ProtectSystem=strict  # Максимальная защита системных файлов
ProtectHome=true  # Скрыть домашние директории
PrivateTmp=true  # Приватный /tmp
PrivateDevices=true  # Скрыть устройства
ProtectKernelTunables=true  # Защитить настройки ядра
ProtectControlGroups=true  # Защитить cgroups
RestrictAddressFamilies=AF_UNIX AF_INET AF_INET6  # Разрешенные socket families
RestrictNamespaces=true  # Запретить создание namespaces
LockPersonality=true  # Зафиксировать personality процесса
```

### **Шаг 5: Настройка лимитов ресурсов**
```ini
[Service]
# Современные лимиты памяти (systemd 230+)
MemoryMax=2G  # Абсолютный лимит памяти
MemoryHigh=1.5G  # Мягкий лимит (начать throttling)
MemorySwapMax=1G  # Лимит swap

# Лимиты CPU через CFS
CPUQuota=150%  # 150% = 1.5 ядра
CPUWeight=100  # Вес в планировщике (1-10000)
IOWeight=100  # Вес для IO

# Традиционные ulimits (через setrlimit)
LimitNOFILE=65536  # Максимум файловых дескрипторов
LimitNPROC=4096  # Максимум процессов
LimitMEMLOCK=infinity  # Снять лимит на locked memory

# Дополнительные лимиты
LimitCORE=0  # Запретить core dumps
LimitDATA=infinity  # Снять лимит на data segment
LimitFSIZE=infinity  # Снять лимит на размер файлов
```

### **Шаг 6: Настройка перезапусков и таймаутов**
```ini
[Service]
# Политика перезапуска при ошибках
Restart=on-failure  # Перезапускать при любом ненулевом exit code
RestartSec=10s  # Ждать 10 секунд перед перезапуском
StartLimitInterval=300  # Окно для подсчета попыток (5 минут)
StartLimitBurst=3  # Максимум 3 попытки в окне

# Таймауты выполнения операций
TimeoutStartSec=300  # 5 минут на запуск
TimeoutStopSec=30  # 30 секунд на graceful остановку
TimeoutAbortSec=30  # 30 секунд до принудительного kill после TimeoutStopSec

# Pre/Post команды
ExecStartPre=/bin/bash -c 'until nc -z localhost 5432; do sleep 1; done'  # Ждать доступности БД
ExecStartPost=/bin/sleep 5  # Подождать после запуска основного процесса
```

## Создание связанных unit файлов

### **Socket Activation Unit**
```bash
# Создаем socket unit для активации по запросу
sudo mcedit /etc/systemd/system/my-complex-app.socket
```

```ini
[Unit]
Description=Socket for My Complex App
PartOf=my-complex-app.service  # Принадлежит основному сервису
Before=my-complex-app.service  # Запускать перед сервисом

[Socket]
# На каких интерфейсах/портах слушать
ListenStream=0.0.0.0:8080  # TCP порт
ListenStream=/var/run/myapp/socket  # Unix socket
SocketUser=myapp  # Владелец сокета
SocketGroup=myapp  # Группа сокета  
SocketMode=0660  # Права на сокет
Accept=yes  # Accept mode (для inetd-style)

[Install]
WantedBy=sockets.target  # Активировать при загрузке sockets
```

### **Timer Unit для периодических задач**
```bash
# Создаем timer для запуска по расписанию
sudo mcedit /etc/systemd/system/my-complex-app-cleanup.timer
```

```ini
[Unit]
Description=Daily cleanup for My Complex App
Requires=my-complex-app-cleanup.service  # Связь с service unit

[Timer]
OnCalendar=daily  # Запускать каждый день
Persistent=true  # Запустить пропущенные таймеры после перезагрузки
RandomizedDelaySec=300  # Случайная задержка до 5 минут

[Install]
WantedBy=timers.target  # Активировать при загрузке timers
```

**И соответствующий service unit:**
```bash
# Service unit для задачи, которую запускает timer
sudo mcedit /etc/systemd/system/my-complex-app-cleanup.service
```

```ini
[Unit]
Description=Cleanup task for My Complex App
After=my-complex-app.service  # Запускать после основного сервиса

[Service]
Type=oneshot  # Задача выполняется один раз и завершается
User=myapp  # От какого пользователя запускать
ExecStart=/usr/local/bin/myapp-cleanup --verbose  # Команда очистки
```

### **Path Unit для реакций на изменения файлов**
```bash
# Создаем path unit для отслеживания изменений файлов
sudo mcedit /etc/systemd/system/my-complex-app-config.path
```

```ini
[Unit]
Description=Watch for config changes in My Complex App

[Path]
PathChanged=/etc/myapp/config.conf  # Отслеживать изменения файла
PathModified=/etc/myapp/  # Отслеживать изменения в директории
Unit=my-complex-app-config-reload.service  # Какой сервис запускать при изменении

[Install]
WantedBy=multi-user.target  # Активировать при стандартной загрузке
```

**И service для перезагрузки конфига:**
```bash
# Service unit для перезагрузки конфигурации
sudo mcedit /etc/systemd/system/my-complex-app-config-reload.service
```

```ini
[Unit]
Description=Reload My Complex App configuration

[Service]
Type=oneshot  # Выполнить один раз
ExecStart=/bin/kill -HUP $MAINPID  # Отправить SIGHUP основному процессу
ExecStartPost=/bin/systemctl reload nginx.service  # Перезагрузить nginx если нужно
```

## Сложные сценарии с несколькими процессами

### **Service с несколькими ExecStartPre**
```ini
[Service]
# Цепочка подготовки перед запуском основного процесса
ExecStartPre=/usr/bin/test -f /etc/myapp/config.conf  # Проверить наличие конфига
ExecStartPre=/usr/bin/mkdir -p /var/run/myapp  # Создать runtime директорию
ExecStartPre=/usr/bin/chown myapp:myapp /var/run/myapp  # Настроить владельца
ExecStartPre=/usr/bin/chmod 755 /var/run/myapp  # Настроить права

# Основной процесс
ExecStart=/usr/local/bin/myapp-server

# Дополнительные процессы после запуска
ExecStartPost=/usr/local/bin/myapp-healthcheck  # Запустить healthcheck
ExecStartPost=/bin/sleep 10  # Подождать 10 секунд
```

### **Service с управлением через сокет**
```ini
[Service]
# Основной процесс, слушающий сокет
ExecStart=/usr/local/bin/myapp --socket /var/run/myapp/socket

# Команды управления через control utility
ExecReload=/usr/local/bin/myappctl reload  # Перезагрузить конфиг
ExecStop=/usr/local/bin/myappctl shutdown  # Graceful shutdown

# Подготовка сокета перед запуском
ExecStartPre=/usr/bin/rm -f /var/run/myapp/socket  # Удалить старый сокет
```

## Проверка и отладка сложного unit

### **Проверка синтаксиса**
```bash
# Проверить синтаксис unit файла на ошибки
systemd-analyze verify /etc/systemd/system/my-complex-app.service

# Показать цепочку критических зависимостей
systemd-analyze critical-chain my-complex-app.service

# Показать время запуска всех сервисов и найти медленные
systemd-analyze blame | grep my-complex-app
```

### **Тестирование сервиса**
```bash
# Тестовый запуск без реальной активации (проверка зависимостей)
systemctl start my-complex-app.service --dry-run

# Показать все зависимости сервиса в виде дерева
systemctl list-dependencies my-complex-app.service

# Показать условия и проверки которые должны выполниться
systemctl show my-complex-app.service -p Conditions,Asserts
```

### **Мониторинг и логи**
```bash
# Просмотр логов в реальном времени с follow
journalctl -u my-complex-app.service -f

# Просмотр логов за определенный период
journalctl -u my-complex-app.service --since "2024-01-01" --until "2024-01-02"

# Проверить статус всех связанных компонентов системы
systemctl status my-complex-app.service my-complex-app.socket my-complex-app.timer
```

### **Отладка проблем**
```bash
# Подробный вывод статуса с полными сообщениями
systemctl status my-complex-app.service -l --no-pager

# Показать все переменные окружения сервиса
systemctl show my-complex-app.service -p Environment,EnvironmentFile

# Показать установленные лимиты ресурсов
systemctl show my-complex-app.service -p LimitNOFILE,MemoryMax,CPUQuota
```

## Best Practices для сложных unit

### **1. Используйте документацию**
```ini
[Unit]
Description=My Complex Application Server
Documentation=man:myapp(8)  # Man page приложения
Documentation=https://github.com/mycompany/myapp/wiki  # Online документация
Documentation=file:/usr/share/doc/myapp/README.md  # Локальная документация
```

### **2. Разделяйте ответственность**
```bash
# Вместо одного монолитного сервиса создайте несколько специализированных:

# API сервер
/etc/systemd/system/myapp-api.service

# Фоновые workers
/etc/systemd/system/myapp-worker.service  

# Планировщик задач
/etc/systemd/system/myapp-scheduler.service

# Target для объединения всех компонентов
/etc/systemd/system/myapp.target
```

### **3. Используйте переменные окружения для гибкости**
```ini
[Service]
# Статические переменные
Environment=CONFIG_PATH=/etc/myapp/config.conf
Environment=LOG_LEVEL=info

# Динамические переменные из файла
EnvironmentFile=/etc/default/myapp

# Использование переменных в команде
ExecStart=/usr/local/bin/myapp --config $CONFIG_PATH --log-level $LOG_LEVEL
```

### **4. Настройте правильные зависимости**
```ini
[Unit]
# Явные временные зависимости
After=network.target database.service cache.service

# Жесткие зависимости (сервис не запустится если эти недоступны)
Requires=database.service

# Мягкие зависимости (попытаться запустить, но не обязательно)
Wants=cache.service

# Условные проверки перед запуском
ConditionPathExists=/etc/myapp/config.conf  # Конфиг должен существовать
AssertPathIsReadWrite=/var/lib/myapp  # Директория должна быть доступна для записи
```

### **5. Обеспечьте отказоустойчивость**
```ini
[Service]
# Политика перезапуска при сбоях
Restart=on-failure  # Перезапускать при любом ненулевом exit code

# Задержка перед перезапуском (дать системе устаканиться)
RestartSec=10s

# Защита от бесконечных перезапусков
StartLimitInterval=300  # Окно времени 5 минут
StartLimitBurst=3  # Максимум 3 попытки в окне

# Таймауты для разных операций
TimeoutStartSec=300  # 5 минут на запуск
```

## Пример полной системы с target

### **Target для группировки связанных сервисов**
```bash
# Создаем target unit для объединения группы сервисов
sudo mcedit /etc/systemd/system/myapp.target
```

```ini
[Unit]
Description=My Application Suite
# Все эти сервисы должны быть активны для работы target
Requires=myapp-api.service myapp-worker.service myapp-scheduler.service
# Target запустится после всех этих сервисов
After=myapp-api.service myapp-worker.service myapp-scheduler.service

[Install]
# Этот target будет запущен при переходе в multi-user режим
WantedBy=multi-user.target
```

### **Управление всей системой через target**
```bash
# Активируем target (создадим симлинки в WantedBy)
sudo systemctl enable myapp.target

# Запускаем всю систему одним командой
sudo systemctl start myapp.target

# Проверяем статус всей системы
sudo systemctl status myapp.target

# Останавливаем всю систему
sudo systemctl stop myapp.target
```

Такой подход позволяет создавать сложные, отказоустойчивые системы с правильными зависимостями, безопасностью и мониторингом!
