# Управление процессами в Linux
Эта статья охватывает основные аспекты управления процессами в Linux и предоставляет инструменты для эффективного мониторинга, диагностики и управления системными ресурсами.

## Мониторинг процессов

### Основные команды ps

```bash
# Информация о текущей командной оболочке
ps -p $$

# Краткий список всех процессов
ps -e | head

# Расширенный формат с полной информацией
ps -ef

# Подробный формат с дополнительными полями
ps lax

# Сортировка по использованию памяти
ps aux --sort=%mem

# Сортировка по использованию CPU
ps aux --sort=%cpu

# Дерево процессов с PID
pstree -p <PID>
```

### Настройка логирования atop

```bash
# Для Ubuntu/Debian
sudo sed -i 's/600/10/' /etc/default/atop
sudo systemctl restart atop

# Проверка логов
ls -lh /var/log/atop/

# Просмотр логов
atop -r /var/log/atop/atop_20241130 -b 21:43
# Используйте t и Shift+t для перемещения по времени
```

**Примечание:** Для CentOS/RHEL конфигурационный файл находится в `/etc/sysconfig/atop`.

## Расшифровка полей вывода ps

- **USER** — учетная запись пользователя, от которой запущен процесс
- **PID** — идентификатор процесса
- **%CPU** — потребление процессорного времени в процентном эквиваленте
- **%MEM** — использование памяти в процентах
- **VSZ** — Virtual Set Size. Виртуальный размер процесса (в килобайтах)
- **RSS** — Resident Set Size. Размер резидентного набора (количество 1K-страниц в памяти)
- **TTY** — терминал, из-под которого был запущен процесс
- **STAT** — текущее состояние процесса
- **START** — дата запуска процесса
- **TIME** — общее время выполнения процесса
- **COMMAND** — команда, запустившая процесс

### Коды состояния процесса (STAT)

- **R** (TASK_RUNNING) — процесс либо выполняется на ЦП, либо ожидает запуска
- **S** (TASK_INTERRUPTIBLE) — спящий, ожидающий события
- **I** (TASK_REPORT_IDLE) — неактивен (inactive)
- **D** (TASK_UNINTERRUPTIBLE) — в состоянии подкачки на диске; используется только если прерывание процесса может привести к непредсказуемому состоянию устройства
- **T** (TASK_STOPPED) — остановлен сигналом SIGSTOP или отладчиком
- **Z** (EXIT_ZOMBIE) — зомби-процесс; дочерний процесс завершился, но родительский еще не вызвал wait()
- **W** — не имеет резидентных страниц (устаревший)
- **<** — высокоприоритетный
- **N** — низкоприоритетный
- **X** (EXIT_DEAD) — родительский процесс очищает оставшуюся структуру дочернего процесса
- **L** — имеет страницы, заблокированные в памяти

## Системные ограничения и диагностика

### Определение числа логических процессоров

```bash
grep "model name" /proc/cpuinfo | wc -l
```

### Максимальное число процессов

В файле **/proc/sys/kernel/pid_max** хранится максимальное значение PID. Когда заканчиваются доступные PID, новые процессы не могут запуститься.

```bash
cat /proc/sys/kernel/pid_max
```

### Настройка ограничений системы

Конфигурационные файлы:
- **/etc/security/limits.conf** — глобальные ограничения пользователей
- **/etc/systemd/system.conf** — ограничения для systemd

## Управление заданиями и приоритетами

### Работа с заданиями в оболочке

```bash
# Просмотр запущенных заданий
jobs -l

# Остановка процесса (сигнал SIGSTOP) и перевод в фон
Ctrl+Z

# Аварийное завершение с дампом ядра
Ctrl+\

# Запуск процесса в фоновом режиме
command &

# Возврат процесса из фона
bg %номер_задания

# Перевод процесса на передний план
fg %номер_задания
```

### Управление приоритетами процессов

Приоритет процесса в Linux определяет, насколько больше процессорного времени будет отдано этому процессу по сравнению с другими. Значение приоритета (nice) может колебаться от 19 (минимальный приоритет) до -20 (максимальный приоритет).

**Важно:** Обычный пользователь может только уменьшать приоритет (увеличивать nice), но не повышать его. Для повышения приоритета требуются права суперпользователя.

```bash
# Запуск процесса с пониженным приоритетом
nice -n 10 apt-get upgrade

# Просмотр текущего значения nice
ps -o pid,comm,nice <PID>

# Изменение приоритета запущенного процесса
renice -n 19 <PID>

# Просмотр процессов с их приоритетами
ps axo pid,comm,nice,cls --sort=-nice
```

### Просмотр лимитов процесса

```bash
# Просмотр всех лимитов для процесса
cat /proc/<PID>/limits

# Альтернативный вариант через ulimit
ulimit -a
```

## Анализ загрузки системы

### Топ-10 процессов по загрузке CPU

```bash
# Способ 1
ps -eo pcpu,pid,user,args | tail -n +2 | sort -k1 -r -n | head -10

# Способ 2
ps aux --sort=-%cpu | head -20

# Способ 3
ps -eo pid,ppid,%cpu,%mem,cmd --sort=-%cpu | head -15

# Способ 4
top -b -n 1 | head -20

# Поиск Java-процессов по CPU
ps -eo pid,ppid,%cpu,%mem,cmd --sort=-%cpu | grep java

# Подробный вывод с групповыми идентификаторами
ps -eo pid,ppid,pgid,sid,%cpu,%mem,cmd --sort=-%cpu | head -15
```

## Работа с зомби-процессами

Зомби-процесс (Z) — это дочерний процесс, который завершил выполнение, но его родительский процесс еще не вызвал системный вызов wait() для получения статуса завершения. Процесс остается в таблице процессов до тех пор, пока родитель не прочитает его статус.

### Обнаружение зомби-процессов

```bash
# Через top (смотрим строку Tasks)
top

# Через ps
ps ux
ps ux | awk '{if($8=="Z") print}'
ps aux | grep 'Z'

# Поиск родительского процесса для зомби
ps -A -ostat,pid,ppid | grep -e '[zZ]'
pstree -p -s <PID_зомби>
```

### Устранение зомби-процессов

1. **Отправка SIGCHLD родителю** — имитирует завершение дочернего процесса:

```bash
kill -s SIGCHLD <PID_родителя>
```

2. **Завершение родительского процесса** (если это безопасно):

```bash
kill <PID_родителя>
```

3. **В крайнем случае — перезагрузка системы**, если зомби-процессы блокируют системные ресурсы.

## Реальное время и планирование

```bash
# Показать или изменить атрибуты планирования реального времени
chrt -p <PID>

# Комбинированный просмотр
ps -o pid,pcpu,nice,comm $(pgrep <pattern1>; pgrep <pattern2>)
```

## Сигналы в Linux

Сигналы — это основной механизм межпроцессного взаимодействия в Unix/Linux для управления процессами.

### Классификация сигналов

#### 1. Основные сигналы управления процессами
- **SIGHUP (1)** — Hangup (перезапуск, перечитывание конфигураций)
- **SIGINT (2)** — Interrupt (Ctrl+C в терминале)
- **SIGQUIT (3)** — Quit (Ctrl+\ в терминале, с дампом памяти)
- **SIGKILL (9)** — Немедленное уничтожение процесса
- **SIGTERM (15)** — Graceful termination (вежливое завершение)
- **SIGSTOP (19)** — Остановка процесса (приостановка выполнения)
- **SIGCONT (18)** — Продолжить выполнение остановленного процесса

#### 2. Сигналы ошибок
- **SIGILL (4)** — Illegal instruction (недопустимая инструкция)
- **SIGTRAP (5)** — Trap (отладочный трап)
- **SIGABRT (6)** — Abort (аварийное завершение)
- **SIGBUS (7)** — Bus error (ошибка шины)
- **SIGFPE (8)** — Floating point exception
- **SIGSEGV (11)** — Segmentation fault

#### 3. Сигналы ввода/вывода и событий
- **SIGPIPE (13)** — Broken pipe (разрыв канала)
- **SIGALRM (14)** — Alarm clock (сигнал таймера)
- **SIGCHLD (17)** — Child status changed

#### 4. Пользовательские сигналы
- **SIGUSR1 (10)** — User-defined signal 1
- **SIGUSR2 (12)** — User-defined signal 2

#### 5. Сигналы реального времени (34-64)
Имеют приоритет и могут быть поставлены в очередь.

### Работа с сигналами

#### Отправка сигналов процессам

```bash
# По номеру сигнала
kill -9 PID          # SIGKILL
kill -15 PID         # SIGTERM

# По имени сигнала
kill -SIGTERM PID
kill -TERM PID
```

#### Просмотр информации о сигналах

```bash
# Список всех сигналов с номерами
kill -L

# Список всех сигналов с именами
kill -l

# Полная документация
man 7 signal
```

#### Распространенные сценарии использования

```bash
# Вежливое завершение процесса
kill -TERM PID       # или kill -15 PID

# Принудительное завершение
kill -KILL PID       # или kill -9 PID

# Перезапуск демона (перечитать конфиг)
kill -HUP PID        # или kill -1 PID

# Приостановить процесс
kill -STOP PID       # или kill -19 PID

# Возобновить процесс
kill -CONT PID       # или kill -18 PID
```

### Важные особенности сигналов

1. **SIGKILL (9)** и **SIGSTOP (19)** нельзя перехватить, игнорировать или заблокировать
2. **SIGTERM (15)** — стандартный сигнал для "вежливого" завершения
3. Процессы могут:
   - Обрабатывать сигналы (установить свой обработчик)
   - Игнорировать большинство сигналов
   - Использовать сигналы по умолчанию

### Примеры обработки сигналов в скриптах

```bash
#!/bin/bash
# Перехват и обработка SIGTERM
trap "echo 'Получен SIGTERM, корректно завершаюсь...'; cleanup; exit 0" SIGTERM

# Перехват нескольких сигналов
trap "echo 'Завершение по Ctrl+C'; exit 1" SIGINT
trap "echo 'Получен SIGHUP'; reload_config" SIGHUP

# Бесконечный цикл с обработкой
while true; do
    sleep 1
done
```

### Диагностика обработки сигналов

```bash
# Посмотреть маску сигналов процесса
grep Sig /proc/<PID>/status

# Отслеживание сигналов в реальном времени
strace -p <PID> -e trace=signal

# Просмотр обработчиков сигналов
cat /proc/<PID>/status | grep -i sig
```

## Практические рекомендации

1. **Всегда начинайте с SIGTERM** — дайте процессу возможность корректно завершиться
2. **Используйте SIGKILL только в крайних случаях** — это может привести к потере данных
3. **Мониторьте зомби-процессы** — они могут указывать на ошибки в программировании
4. **Настраивайте приоритеты для критических процессов** — используйте nice и renice
5. **Изучите /proc файловую систему** — она содержит детальную информацию о процессах

## Полезные команды для ежедневного использования

```bash
# Поиск процесса по имени
pgrep -f "pattern"

# Детальная информация о процессе
ps -fp <PID>

# Мониторинг в реальном времени
htop
top -d 1 -p <PID1>,<PID2>

# Просмотр открытых файлов процессом
lsof -p <PID>

# Просмотр потребления памяти
pmap -x <PID>
```
